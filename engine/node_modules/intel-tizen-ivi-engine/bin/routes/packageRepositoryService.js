var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var abstractService = require("./abstractService")
var express = require("express")

var fs = require("fs")
var os = require("os")
var url = require("url")
var path = require("path")
var util = require("util")
var elementtree = require('elementtree');
var request = require('request');
var zip = require('zip');
var mkdirp = require('mkdirp');
var PackageRepositoryService = (function (_super) {
    __extends(PackageRepositoryService, _super);
    function PackageRepositoryService(options) {
        _super.call(this, {
    name: "PackageRepository",
    endpointName: "packageRepository",
    description: "Package repository",
    apiClassName: "PackageRepository",
    indexView: "packageRepository"
});
        this.options = options;
        this.availableApplications = [];
        this.runningInstallation = false;
        this.carThemes = [];
        this.userThemes = [];
        this.categories = [
            {
                id: "music_and_audio",
                description: "",
                name: "Media",
                url: "/PackageRepository/category?id=music_and_audio"
            }, 
            {
                id: "utilities",
                description: "",
                name: "Utilities",
                url: "/PackageRepository/category?id=utilities"
            }, 
            {
                id: "user_theme",
                description: "",
                name: "User themes",
                url: "/PackageRepository/category?id=user_theme"
            }
        ];
        this.logger.info("Application path: %s", this.options.baseApplicationPath);
        this.logger.info("Themes path: %s", this.options.baseThemePath);
        this.logger.info("Data path: %s", this.options.baseDataPath);
        this.logger.info("Theme silent install is: %s", this.options.doSilentInstall);
        this.logger.info("Latest packages url: %s", this.options.latestPackagesUrl);
        this.logger.info("Available packages url: %s", this.options.availablePackagesUrl);
        this.logger.info("Device name: %s", this.options.deviceName);
        this.logger.info("Engine version: %s", this.options.engineVersion);
    }
    PackageRepositoryService.prototype.attachApplication = function (aApplication) {
        var self = this;
        this.actions.splice(this.actions.length, 0, {
            type: "get",
            title: "Get promoted applications",
            apiMethod: "getPromotedApplications",
            endpoint: "/promoted",
            callback: this.getPromotedApplications
        }, {
            type: "get",
            title: "Get most popular applications",
            apiMethod: "getPopularApplications",
            endpoint: "/popular",
            callback: this.getPopularApplications
        }, {
            type: "get",
            title: "Get available applications",
            apiMethod: "getAvailableApplications",
            endpoint: "/available",
            callback: this.getAvailableApplications
        }, {
            type: "get",
            title: "Get application detail related to id specified as parameter.",
            apiMethod: "getApplicationDetail",
            endpoint: "/applicationDetail",
            callback: this.getApplicationDetail,
            parameters: [
                {
                    name: "id",
                    type: "text",
                    value: "com.intel.tizen/applicationstore"
                }
            ]
        }, {
            type: "get",
            title: "Get category related to id specified as parameter.",
            apiMethod: "getCategoryApplications",
            endpoint: "/category",
            callback: this.getCategory,
            parameters: [
                {
                    name: "id",
                    type: "text",
                    value: "utilities"
                }
            ]
        }, {
            type: "get",
            title: "Get list of categories",
            apiMethod: "getCategories",
            endpoint: "/categories",
            callback: this.getCategories
        }, {
            type: "get",
            title: "Get image from remote Package Repository",
            endpoint: "/image",
            callback: this.getImage
        }, {
            type: "post",
            title: "Install from URL",
            endpoint: "/installFromUrl",
            callback: this.installFromUrl,
            parameters: [
                {
                    name: "url",
                    type: "text",
                    value: "http://80.242.18.56:8080/application-homescreen.wgt"
                }
            ]
        }, {
            type: "post",
            title: "Install",
            endpoint: "/install",
            apiMethod: "install",
            callback: this.install,
            parameters: [
                {
                    name: "id",
                    type: "text",
                    value: "http://com.intel.tizen/store"
                }
            ]
        }, {
            type: "post",
            title: "Uninstall",
            endpoint: "/uninstall",
            apiMethod: "uninstall",
            callback: this.uninstall,
            parameters: [
                {
                    name: "id",
                    type: "text",
                    value: "http://com.intel.tizen/store"
                }
            ]
        });
        _super.prototype.attachApplication.call(this, aApplication);
        this.on("initialized", this.__checkForAvailableApplications);
        fs.readFile(path.join(this.options.baseDataPath, "available.json"), function (err, data) {
            if(!err) {
                var available = JSON.parse(data.toString());
                self.logger.info("Available package data for %d applications loaded.", available.length);
                available.map(function (value) {
                    self.availableApplications.push(value);
                });
            } else {
                self.logger.error(err);
            }
            fs.readdir(self.options.baseApplicationPath, function (appError, files) {
                if(!appError) {
                    files.map(function (value) {
                        self.__linkApplication(value);
                    });
                } else {
                    self.logger.error(appError);
                }
                self.logger.info("Applications loaded & detected ...");
                self.emit("initialized", {
                });
            });
        });
        this.__loadThemes();
    };
    PackageRepositoryService.prototype.__getCarTheme = function () {
        var selectedCarTheme;
        this.carThemes.forEach(function (aItem) {
            selectedCarTheme = aItem.selected ? aItem : selectedCarTheme;
        });
        return selectedCarTheme;
    };
    PackageRepositoryService.prototype.__getUserTheme = function () {
        var selectedUserTheme;
        this.userThemes.forEach(function (aItem) {
            selectedUserTheme = aItem.selected ? aItem : selectedUserTheme;
        });
        return selectedUserTheme;
    };
    PackageRepositoryService.prototype.__loadThemes = function () {
        var self = this;
        var selectedCarTheme = this.__getCarTheme(), selectedUserTheme = this.__getUserTheme();
        this.carThemes = [];
        this.userThemes = [];
        fs.readdirSync(this.options.baseThemePath).forEach(function (aManufacturerItem) {
            var manufacturerThemePath = path.join(self.options.baseThemePath, aManufacturerItem);
            fs.readdirSync(manufacturerThemePath).forEach(function (aThemeItem) {
                var themeId = aManufacturerItem + "/" + aThemeItem;
                var themePath = path.join(manufacturerThemePath, aThemeItem);
                var themeJson = path.join(themePath, "theme.json");
                if(fs.existsSync(themeJson)) {
                    var themeData = JSON.parse(fs.readFileSync(themeJson).toString());
                    var isUserTheme = themeData.type === "user";
                    var themeArray = isUserTheme ? self.userThemes : self.carThemes;
                    var selectedTheme = isUserTheme ? selectedUserTheme : selectedCarTheme;
                    themeData.iconUrl = util.format("%s/icon?id=%s", "/themeengine", themeData.id);
                    themeData.selected = selectedTheme ? selectedTheme.id == themeData.id : false;
                    themeArray.push(themeData);
                    self.logger.info("Found theme '%s'", themeId);
                } else {
                    self.logger.warn("Theme definition file '%s' was not found, ignoring theme '%s'", themeJson, themeId);
                }
            });
        });
        selectedCarTheme = this.__getCarTheme() , selectedUserTheme = this.__getUserTheme();
        if(!selectedCarTheme && this.carThemes.length > 0) {
            this.carThemes[0].selected = true;
        }
        if(!selectedUserTheme && this.userThemes.length > 0) {
            this.userThemes[0].selected = true;
        }
    };
    PackageRepositoryService.prototype.getInstalledApps = function () {
        this.logger.info("Getting current applications from: %s", this.options.baseApplicationPath);
        var applications = [];
        var appDirs = fs.readdirSync(this.options.baseApplicationPath);
        for(var i in appDirs) {
            try  {
                var appDir = appDirs[i];
                if(typeof appDir == "string") {
                    var applicationDirectory = path.join(this.options.baseApplicationPath, appDir);
                    var configFile = path.join(applicationDirectory, "config.xml");
                    if(fs.existsSync(configFile)) {
                        var etree = elementtree.parse(fs.readFileSync(configFile).toString());
                        var itemId = etree.find("./").attrib.id;
                        applications.push({
                            id: itemId,
                            version: etree.find("./").attrib.version,
                            show: true,
                            name: etree.findtext("./name"),
                            iconPath: etree.find("./icon").attrib.src,
                            __applicationDirectory: appDir
                        });
                        this.availableApplications.forEach(function (aItem) {
                            if(aItem.id == itemId) {
                                aItem.installed = true;
                                return false;
                            }
                        });
                    } else {
                        this.logger.warn("Config.xml file for application %s not found, skipping ...", appDir);
                    }
                }
            } catch (exp) {
                this.logger.error(exp);
            }
        }
        return applications;
    };
    PackageRepositoryService.prototype.getImage = function (aRequest, aResponse) {
        var redirect = url.resolve(this.options.availablePackagesUrl, aRequest.query.path);
        this.logger.info("Loading remote image from %s", redirect);
        var streamer = request({
            url: redirect,
            headers: this.__getHeaders()
        });
        streamer.addListener('response', function (res) {
            aResponse.header('Content-Type', res.headers["content-type"]);
        });
        streamer.addListener('data', function (chunk) {
            aResponse.write(chunk, "binary");
        });
        streamer.addListener('end', function () {
            aResponse.end();
        });
    };
    PackageRepositoryService.prototype.__getHeaders = function () {
        return {
            "X-Device-Name": this.options.deviceName,
            "user-agent": util.format("Mozilla/5.0 (%s %s, %s, %s) NodeJS/%s IviEngine/%s", os.type(), os.release(), os.platform(), os.arch(), process.version, this.options.engineVersion),
            "Authorization": "Basic aW50ZWw6VGlaM040NTYh"
        };
    };
    PackageRepositoryService.prototype.__checkForAvailableApplications = function () {
        var self = this;
        this.logger.info("Checking app/theme repositories from: %s", this.options.availablePackagesUrl);
        var req = request({
            url: this.options.availablePackagesUrl,
            headers: this.__getHeaders()
        }, function (error, response, body) {
            try  {
                self.logger.info("Download status code %d, error: %s ", response ? response.statusCode : 0, error);
                if(!error) {
                    self.availableApplications = JSON.parse(body);
                    self.availableApplications.forEach(function (application) {
                        application.iconUrl = util.format("%s/image?path=%s", self.basePath, encodeURIComponent(application.iconUrl));
                        application.screenshots = application.screenshots.map(function (screenshot) {
                            return util.format("%s/image?path=%s", self.basePath, encodeURIComponent(screenshot));
                        });
                    });
                } else {
                    self.logger.error("Error downloading available packages", error);
                }
            } catch (ex) {
                self.logger.error("Exception downloading available packages", error);
            }finally {
                self.__checkForApplicationUpdates();
            }
        });
    };
    PackageRepositoryService.prototype.__checkForApplicationUpdates = function () {
        var self = this;
        this.logger.info("Checking latest app/theme packages from: %s", this.options.latestPackagesUrl);
        var installedApplication = this.getInstalledApps();
        this.carThemes.forEach(function (theme) {
            installedApplication.push(theme);
        });
        this.userThemes.forEach(function (theme) {
            installedApplication.push(theme);
        });
        request({
            url: this.options.latestPackagesUrl,
            headers: this.__getHeaders()
        }, function (error, response, body) {
            try  {
                self.logger.info("Download status code %d, error: %s ", response ? response.statusCode : 0, error);
                if(!error) {
                    var data = JSON.parse(body.toString());
                    var installableApplications = [];
                    data.forEach(function (remoteItem) {
                        if(remoteItem.id) {
                            var found = false;
                            installedApplication.forEach(function (installedItem) {
                                if(installedItem.id === remoteItem.id) {
                                    self.logger.debug("%s local v.%s, remote v.%s", installedItem.id, installedItem.version, remoteItem.version);
                                    if(remoteItem.version > installedItem.version) {
                                        self.logger.info("Updating item %s [version %s vs. %s]", remoteItem.id, installedItem.version, remoteItem.version);
                                        installableApplications.push(remoteItem);
                                    }
                                    found = true;
                                    return true;
                                }
                            });
                            if(!found) {
                                installableApplications.push(remoteItem);
                            }
                        }
                    });
                    installableApplications.forEach(function (aItem) {
                        self.logger.info("Application %s have new version %s", aItem.id, aItem.version);
                        if(self.options.doSilentInstall && aItem.silentInstall) {
                            self.logger.info("Performing silent install");
                            self.__install(aItem.id, function () {
                            });
                        }
                    });
                }
            } catch (ex) {
                self.logger.error(ex);
            }finally {
                setTimeout(function () {
                    self.__checkForAvailableApplications();
                }, 20000);
            }
        });
    };
    PackageRepositoryService.prototype.__linkApplication = function (aApplicationName) {
        var appPath = path.join(this.options.baseApplicationPath, aApplicationName);
        var appName = "/application/" + aApplicationName;
        this.logger.info("Linking %s to %s", appName, appPath);
        this.applicationRoot.use(appName, express.static(appPath));
    };
    PackageRepositoryService.prototype.getPromotedApplications = function (aRequest, aResponse) {
        var retValues = [];
        this.availableApplications.forEach(function (element, index) {
            if(element.isPromoted) {
                retValues.push(element);
            }
        });
        if(retValues.length === 0) {
            var errorObj = {
                error: 'There is no such promoted application in repository'
            };
            aResponse.json(errorObj);
        } else {
            aResponse.json(retValues);
        }
    };
    PackageRepositoryService.prototype.__install = function (aId, aCallback) {
        var self = this;
        var downloadUrl = "http://intel:TiZ3N456!@80.242.18.56:8080/download/application-" + aId.split("/").pop() + ".wgt";
        this.availableApplications.forEach(function (aItem) {
            if(aItem.id == aId) {
                if(!!aItem.downloadUrl) {
                    downloadUrl = url.resolve(self.options.latestPackagesUrl, aItem.downloadUrl);
                } else {
                    downloadUrl = aItem.category_id === "user_themes" ? "http://80.242.18.56/idcs/services/themes/downloadTheme?themeId=" + aId : downloadUrl;
                }
            }
        });
        this.logger.info("Download url: %s", downloadUrl);
        this.__installApplication(downloadUrl, aCallback);
    };
    PackageRepositoryService.prototype.install = function (aRequest, aResponse) {
        var applicationId = aRequest.body.id;
        this.logger.info("Attempt to install %s", applicationId);
        this.__install(applicationId, function (error, response) {
            aResponse.json({
                response: response,
                error: !!error ? error.message : error
            });
        });
    };
    PackageRepositoryService.prototype.__installApplication = function (aDownloadUrl, aCallback) {
        if(this.runningInstallation) {
            this.logger.warn("Another installation is running, skipping call ...");
            aCallback("Another installation in progress");
        } else {
            this.runningInstallation = true;
            var self = this;
            var callback = function (error, response) {
                self.runningInstallation = false;
                aCallback(error, response);
            };
            this.logger.info("Downloading package from: %s", aDownloadUrl);
            var tempBaseName = util.format("download_%d", new Date().getTime());
            var tempFile = path.join(os.tmpDir(), tempBaseName + ".zip");
            var req = request({
                url: aDownloadUrl,
                headers: this.__getHeaders()
            }, function (error, response, body) {
                self.logger.info("Download status %d, error: %s", response ? response.statusCode : 0, error);
                try  {
                    if(!error && response.statusCode == 200) {
                        fs.readFile(tempFile, function (err, data) {
                            if(err) {
                                callback(err);
                            } else {
                                var isApplication, outputDir, itemId;
                                zip.Reader(data).forEach(function (entry) {
                                    var entryName = entry.getName();
                                    if(entryName === "theme.json") {
                                        self.logger.info("Found theme.json file, parsing ...");
                                        try  {
                                            isApplication = false;
                                            itemId = JSON.parse(entry.getData().toString()).id.replace("http://", "");
                                            outputDir = path.join(self.options.baseThemePath, itemId);
                                            return true;
                                        } catch (ex) {
                                            callback(ex);
                                        }
                                    }
                                    if(entryName === "config.xml") {
                                        self.logger.info("Found config.xml file, parsing ...");
                                        try  {
                                            var etree = elementtree.parse(entry.getData().toString());
                                            isApplication = true;
                                            itemId = etree.find("./").attrib.id.toLowerCase().replace("http://", "").replace("/", "_");
                                            outputDir = path.join(self.options.baseApplicationPath, itemId);
                                            return true;
                                        } catch (ex) {
                                            callback(ex);
                                        }
                                    }
                                });
                                if(!!outputDir && !!itemId) {
                                    try  {
                                        self.logger.info("Unzipping package to dir %s", outputDir);
                                        zip.Reader(data).forEach(function (entry) {
                                            var entryName = entry.getName();
                                            var outputPath = path.join(outputDir, entryName);
                                            var directoryName = path.dirname(outputPath);
                                            if(!fs.existsSync(directoryName)) {
                                                self.logger.debug("Creating directory %s", directoryName);
                                                mkdirp.sync(directoryName);
                                            }
                                            self.logger.debug("Writing %s", outputPath);
                                            fs.writeFileSync(outputPath, entry.getData());
                                        });
                                        if(isApplication) {
                                            self.__linkApplication(itemId);
                                            self.emit("changed", {
                                                application: itemId,
                                                type: "installedApplication"
                                            });
                                        } else {
                                            self.emit("changed", {
                                                theme: "http://" + itemId,
                                                type: "installedTheme"
                                            });
                                        }
                                        callback(null, "OK");
                                    } catch (ex) {
                                        self.logger.error("Exception occured during unpacking", ex);
                                    }finally {
                                        self.logger.info("Removing file %s", tempFile);
                                        fs.unlinkSync(tempFile);
                                    }
                                } else {
                                    callback("Downloaded package is not an application or theme, ignoring ...");
                                }
                            }
                        });
                    }
                } catch (ex) {
                    callback(ex);
                }
            });
            var contentLength = 0, received = 0, lastTick = new Date().getTime();
            req.on("response", function (res) {
                contentLength = parseInt(res.headers["content-length"], 10);
            });
            req.on("data", function (data) {
                received += data.length;
                var progress = received / contentLength;
                var currentTick = new Date().getTime();
                if((currentTick - lastTick) > 2000) {
                    self.logger.debug("%s: %d kB downloaded", tempFile, Math.round(received / 1024));
                    lastTick = currentTick;
                }
            });
            req.pipe(fs.createWriteStream(tempFile));
        }
    };
    PackageRepositoryService.prototype.getPopularApplications = function (aRequest, aResponse) {
        var retValues = [];
        this.availableApplications.forEach(function (element, index) {
            if(String(element.isPopular) == "true") {
                retValues.push(element);
            }
        });
        if(retValues.length === 0) {
            var errorObj = {
                error: 'There is no popular application in repository'
            };
            aResponse.json(errorObj);
        } else {
            aResponse.json(retValues);
        }
    };
    PackageRepositoryService.prototype.getAvailableApplications = function (aRequest, aResponse) {
        aResponse.json(this.availableApplications);
    };
    PackageRepositoryService.prototype.getApplicationDetail = function (aRequest, aResponse) {
        var id = aRequest.param("id");
        var result;
        this.logger.info("Requesting application detail for %s", id);
        if(!!id) {
            result = this.availableApplications.filter(function (app) {
                return app.id == id;
            });
            result = result.length > 0 ? result.pop() : undefined;
            if(!result) {
                result = {
                    error: 'There is no such application in repository'
                };
            }
        } else {
            result = {
                error: 'Missing id parameter'
            };
        }
        aResponse.json(result);
    };
    PackageRepositoryService.prototype.getCategory = function (aRequest, aResponse) {
        var id = aRequest.param('id');
        if(id === undefined) {
            var errorObj = {
                error: 'Missing id parameter'
            };
            aResponse.json(errorObj);
            return;
        }
        var retValues = [];
        this.availableApplications.forEach(function (element, index) {
            if(String(element.category_id) == String(id)) {
                retValues.push(element);
            }
        });
        if(retValues.length === 0) {
            var errorObj = {
                error: 'There is no such category in repository'
            };
            aResponse.json(errorObj);
        } else {
            aResponse.json(retValues);
        }
    };
    PackageRepositoryService.prototype.getCategories = function (aRequest, aResponse) {
        aResponse.json(this.categories);
    };
    PackageRepositoryService.prototype.installFromUrl = function (aRequest, aResponse) {
        var self = this;
        var downloadUrl = aRequest.body.url;
        this.__installApplication(downloadUrl, function (error, response) {
            aResponse.json({
                response: response,
                error: error
            });
        });
    };
    PackageRepositoryService.prototype.__deleteFolderRecursive = function (path) {
        var self = this;
        var files = [];
        if(fs.existsSync(path)) {
            files = fs.readdirSync(path);
            files.forEach(function (file, index) {
                var curPath = path + "/" + file;
                if(fs.statSync(curPath).isDirectory()) {
                    self.__deleteFolderRecursive(curPath);
                } else {
                    fs.unlinkSync(curPath);
                }
            });
            fs.rmdirSync(path);
        }
    };
    PackageRepositoryService.prototype.uninstall = function (aRequest, aResponse) {
        var self = this;
        var result = [];
        var applicationId = aRequest.body.id;
        this.getInstalledApps().forEach(function (aItem) {
            if(aItem.id == applicationId) {
                try  {
                    self.logger.info("Uninstalling application %s", applicationId);
                    self.__deleteFolderRecursive(path.join(self.options.baseApplicationPath, aItem.__applicationDirectory));
                    result = self.getInstalledApps();
                    self.emit('changed', {
                        application: aItem,
                        type: "uninstalled"
                    });
                } catch (ex) {
                    self.logger.error(ex);
                }
                return false;
            }
        });
        aResponse.json(result);
    };
    return PackageRepositoryService;
})(abstractService.AbstractService);
exports.PackageRepositoryService = PackageRepositoryService;
