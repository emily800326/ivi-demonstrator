<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\routes\packageRepositoryService.ts - Intel Tizen IVI Engine</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="https:&#x2F;&#x2F;www.tizen.org&#x2F;sites&#x2F;all&#x2F;themes&#x2F;tizen_theme&#x2F;logo.png" title="Intel Tizen IVI Engine"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.2012105.151454</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/AbstractService.AbstractService.html">AbstractService.AbstractService</a></li>
            
                <li><a href="..&#x2F;classes/AbstractService.AbstractServiceOptions.html">AbstractService.AbstractServiceOptions</a></li>
            
                <li><a href="..&#x2F;classes/AbstractService.EndpointAction.html">AbstractService.EndpointAction</a></li>
            
                <li><a href="..&#x2F;classes/AbstractService.EndpointActionParameter.html">AbstractService.EndpointActionParameter</a></li>
            
                <li><a href="..&#x2F;classes/ApiEndpointBase.ApiEndpointBase.html">ApiEndpointBase.ApiEndpointBase</a></li>
            
                <li><a href="..&#x2F;classes/AudioService.AudioService.html">AudioService.AudioService</a></li>
            
                <li><a href="..&#x2F;classes/AudioService.StatusData.html">AudioService.StatusData</a></li>
            
                <li><a href="..&#x2F;classes/CarIndicatorService.CarIndicatorService.html">CarIndicatorService.CarIndicatorService</a></li>
            
                <li><a href="..&#x2F;classes/CarIndicatorService.RandomizerData.html">CarIndicatorService.RandomizerData</a></li>
            
                <li><a href="..&#x2F;classes/CarIndicatorService.StatusData.html">CarIndicatorService.StatusData</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.AlphabetBookmark.html">com.intel.tizen.coulomb.2012.AlphabetBookmark</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.AudioPlayer.html">com.intel.tizen.coulomb.2012.AudioPlayer</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.BottomPanel.html">com.intel.tizen.coulomb.2012.BottomPanel</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.BoxCaption.html">com.intel.tizen.coulomb.2012.BoxCaption</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.ButtonControlsObj.html">com.intel.tizen.coulomb.2012.ButtonControlsObj</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.Carousel.html">com.intel.tizen.coulomb.2012.Carousel</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.Clock.html">com.intel.tizen.coulomb.2012.Clock</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.ClockPlugin.html">com.intel.tizen.coulomb.2012.ClockPlugin</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.global.html">com.intel.tizen.coulomb.2012.global</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.jQuery.html">com.intel.tizen.coulomb.2012.jQuery</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.Library.html">com.intel.tizen.coulomb.2012.Library</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.MusicLibraryFileSystem.html">com.intel.tizen.coulomb.2012.MusicLibraryFileSystem</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.progressBarPlugin.html">com.intel.tizen.coulomb.2012.progressBarPlugin</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.Settings.html">com.intel.tizen.coulomb.2012.Settings</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.Tabs.html">com.intel.tizen.coulomb.2012.Tabs</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.Themes.html">com.intel.tizen.coulomb.2012.Themes</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.TopBarIcons.html">com.intel.tizen.coulomb.2012.TopBarIcons</a></li>
            
                <li><a href="..&#x2F;classes/Engine.Server.html">Engine.Server</a></li>
            
                <li><a href="..&#x2F;classes/EventSourceDispatcher.EventSourceDispatcher.html">EventSourceDispatcher.EventSourceDispatcher</a></li>
            
                <li><a href="..&#x2F;classes/EventSourceDispatcher.EventUpdateData.html">EventSourceDispatcher.EventUpdateData</a></li>
            
                <li><a href="..&#x2F;classes/HomeScreenService.HomeScreenService.html">HomeScreenService.HomeScreenService</a></li>
            
                <li><a href="..&#x2F;classes/PackageRepositoryService.AvailablePackageData.html">PackageRepositoryService.AvailablePackageData</a></li>
            
                <li><a href="..&#x2F;classes/PackageRepositoryService.CategoryData.html">PackageRepositoryService.CategoryData</a></li>
            
                <li><a href="..&#x2F;classes/PackageRepositoryService.InstalledPackageData.html">PackageRepositoryService.InstalledPackageData</a></li>
            
                <li><a href="..&#x2F;classes/PackageRepositoryService.PackageEventData.html">PackageRepositoryService.PackageEventData</a></li>
            
                <li><a href="..&#x2F;classes/PackageRepositoryService.PackageRepositoryOptions.html">PackageRepositoryService.PackageRepositoryOptions</a></li>
            
                <li><a href="..&#x2F;classes/PackageRepositoryService.PackageRepositoryService.html">PackageRepositoryService.PackageRepositoryService</a></li>
            
                <li><a href="..&#x2F;classes/PackageRepositoryService.ThemeData.html">PackageRepositoryService.ThemeData</a></li>
            
                <li><a href="..&#x2F;classes/PersistentConsole.console.html">PersistentConsole.console</a></li>
            
                <li><a href="..&#x2F;classes/ThemeEngineService.ThemeEngineService.html">ThemeEngineService.ThemeEngineService</a></li>
            
                <li><a href="..&#x2F;classes/TizenApplicationStubService.TizenApplicationStubService.html">TizenApplicationStubService.TizenApplicationStubService</a></li>
            
                <li><a href="..&#x2F;classes/UserStatusService.UserDetails.html">UserStatusService.UserDetails</a></li>
            
                <li><a href="..&#x2F;classes/UserStatusService.UserSettings.html">UserStatusService.UserSettings</a></li>
            
                <li><a href="..&#x2F;classes/UserStatusService.UserStatusService.html">UserStatusService.UserStatusService</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\routes\packageRepositoryService.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;&#x2F;&#x2F; &lt;reference path=&#x27;..&#x2F;extern&#x2F;express.d.ts&#x27;&#x2F;&gt;

import abstractService = module(&quot;abstractService&quot;);
import express = module(&quot;express&quot;);
import child_process = module(&quot;child_process&quot;);
import fs = module(&quot;fs&quot;);
import os = module(&quot;os&quot;);
import url = module(&quot;url&quot;);
import path = module(&quot;path&quot;);
import util = module(&quot;util&quot;);

&#x2F;**
 * @namespace PackageRepositoryService
 *&#x2F;

var elementtree = require(&#x27;elementtree&#x27;);
var request = require(&#x27;request&#x27;);
var zip = require(&#x27;zip&#x27;);
var mkdirp = require(&#x27;mkdirp&#x27;);

&#x2F;**
* Wraps information about installed package
* @class InstalledPackageData
*&#x2F;
export interface InstalledPackageData {
    &#x2F;** 
    * ID of the package in W3C widget identificator form.
    * @property id
    * @type {String}
    *&#x2F;
    id: string;
    &#x2F;** 
    * Indicates if package should be displayed in Store application.
    * @property show
    * @type {Boolean}
    *&#x2F;
    show: bool;
    &#x2F;** 
    * Human-readable name of package.
    * @property name
    * @type {String}
    *&#x2F;
    name: string;
    &#x2F;** 
    * Path to icon file inside package.
    * @property iconPath
    * @type {String}
    *&#x2F;
    iconPath: string;
    &#x2F;** 
    * Version of package
    * @property version
    * @type {String}
    *&#x2F;
    version: string;
    &#x2F;** 
    * Application directory in filesystem.
    * @private
    * @property __applicationDirectory
    * @type {String}
    *&#x2F;
    __applicationDirectory: string;
}

&#x2F;**
* Wraps information about theme
* @class ThemeData
*&#x2F;
export interface ThemeData {
    &#x2F;** 
    * ID of the theme in W3C widget identificator form.
    * @property id
    * @type {String}
    *&#x2F;
    id: string;
    &#x2F;** 
    * Indicates if theme is currently selected.
    * @property selected
    * @type {Boolean}
    *&#x2F;
    selected: bool;
}

&#x2F;**
* Wraps information about package event
* @class PackageEventData
*&#x2F;
export interface PackageEventData {
    &#x2F;** 
    * ID of the application
    * @optional
    * @property application
    * @type {String}
    *&#x2F;
    application?: string;
    &#x2F;** 
    * ID of the theme
    * @optional
    * @property theme
    * @type {String}
    *&#x2F;
    theme?: string;
    &#x2F;** 
    * Type of event. Allowed values are &#x60;installedApplication&#x60;, &#x60;installedTheme&#x60; and &#x60;uninstalled&#x60;
    * @property type
    * @type {String}
    *&#x2F;
    type: string;
}

&#x2F;**
* Wraps information about category
* @class CategoryData
*&#x2F;
interface CategoryData {
    &#x2F;** 
    * ID of the category
    * @property id
    * @type {String}
    *&#x2F;
    id: string;
    &#x2F;** 
    * Human-readable description of category.
    * @property description
    * @type {String}
    *&#x2F;
    description: string;
    &#x2F;** 
    * Human-readable name of category.
    * @property name
    * @type {String}
    *&#x2F;
    name: string;
    &#x2F;** 
    * Relative URL to category packages
    * @property url
    * @type {String}
    *&#x2F;
    url: string;
}

&#x2F;**
* Wraps options for &#x60;PackageRepository&#x60;
* @class PackageRepositoryOptions
*&#x2F;
export interface PackageRepositoryOptions {
    &#x2F;** 
    * Root path to applications directory
    * @property baseApplicationPath
    * @type {String}
    *&#x2F;
    baseApplicationPath: string;
    &#x2F;** 
    * Root path to themes directory
    * @property baseThemePath
    * @type {String}
    *&#x2F;
    baseThemePath: string;
    &#x2F;** 
    * Root path to data directory with default application data
    * @property baseDataPath
    * @type {String}
    *&#x2F;
    baseDataPath: string;
    &#x2F;**
     * Toggles silent installation of new packages and themes from remote Package Repository marked with &#x60;AvailablePackageData.silentInstall&#x60; flag.
     * @property doSilentInstall
     * @type {Boolean}
    *&#x2F;
    doSilentInstall: bool;
    &#x2F;**
     * Defines remote Package Repository URL for latest package information.
     * @property latestPackagesUrl
     * @type {String}
    *&#x2F;
    latestPackagesUrl: string;
    &#x2F;**
     *  Defines remote Package Repository URL for all available package information.
     * @property availablePackagesUrl
     * @type {String}
    *&#x2F;
    availablePackagesUrl: string;
    &#x2F;**
     * Defines device name for identification with Package Repository.
     * @property deviceName
     * @type {String}
    *&#x2F;
    deviceName: string;
    &#x2F;**
     * Version of package for identification with Package Repository.
     * @property engineVersion
     * @type {String}
    *&#x2F;
    engineVersion: string;
}

&#x2F;**
* Wraps options for &#x60;PackageRepository&#x60;
* @extends PackageRepositoryService.InstalledPackageData
* @class AvailablePackageData
*&#x2F;
interface AvailablePackageData extends InstalledPackageData {
    &#x2F;** 
    * Human-readable description of category.
    * @property description
    * @type {String}
    *&#x2F;
    description: string;
    &#x2F;** 
    * Price defined for package.
    * @property price
    * @type {Float}
    *&#x2F;
    price: number;
    &#x2F;** 
    * Package rating.
    * @property rating
    * @type {Integer}
    *&#x2F;
    rating: number;
    &#x2F;** 
    * Version of package
    * @property version
    * @type {String}
    *&#x2F;
    version: string;
    &#x2F;** 
    * Indicates if package is installed
    * @property installed
    * @type {Boolean}
    *&#x2F;
    installed: bool;
    &#x2F;** 
    * Indicates if package is marked as promoted
    * @property isPromoted
    * @type {Boolean}
    *&#x2F;
    isPromoted: bool;
    &#x2F;** 
    * Indicates if package is marked as popular
    * @property isPopular
    * @type {Boolean}
    *&#x2F;
    isPopular: bool;
    &#x2F;** 
    * Indicates if package is marked for silent installation
    * @property silentInstall
    * @optional
    * @type {Boolean}
    *&#x2F;
    silentInstall?: bool;
    &#x2F;** 
    * Package category
    * @property category
    * @type {String}
    *&#x2F;
    category: string;
    &#x2F;** 
    * Package category ID
    * @property category_id
    * @type {String}
    *&#x2F;
    category_id: string;
    &#x2F;** 
    * Package download URL
    * @property downloadURL
    * @optional
    * @type {String}
    *&#x2F;
    downloadUrl?: string;
    &#x2F;** 
    * Defines list of available screenshot images
    * @property screenshots
    * @optional
    * @type {String[]}
    *&#x2F;
    screenshots?: string[];
    &#x2F;** 
    * Defines icon URL
    * @property iconUrl
    * @optional
    * @type {String}
    *&#x2F;
    iconUrl?: string;
}

&#x2F;** 
* &#x60;&#x2F;packageRepository &#x60;
*
* Manages categories and lists of available packages from remote Package Repository, installation and uninstallation of following items:
*
* * Applications (WGT packages, see W3C Widget specification for more information)
* * Themes (THM packages, see &#x60;ThemeEngine&#x60; API for more information about structure)
*
* Fast way to install new applications is either from web browser in Package repository section or from command line by invoking e.g.
*
*     curl --data &quot;url=http:&#x2F;&#x2F;vendor.com&#x2F;package.name&quot; http:&#x2F;&#x2F;localhost:8088&#x2F;packageRepository&#x2F;install
*
* As minimum setup there should be at least Home screen and Store applications which can be installed by calling:
*
*     curl --data &quot;url=http:&#x2F;&#x2F;com.intel.tizen&#x2F;homescreen&quot; http:&#x2F;&#x2F;localhost:8088&#x2F;packageRepository&#x2F;install
*     curl --data &quot;url=http:&#x2F;&#x2F;com.intel.tizen&#x2F;store&quot; http:&#x2F;&#x2F;localhost:8088&#x2F;packageRepository&#x2F;install
*
* Service also allows silent installation of new packages or themes if both package declares that it is enabled for silent installation (&#x60;AvailablePackageData.silentInstall&#x60;) and
* configuration option &#x60;PackageRepositoryOptions.doSilentInstall&#x60; is turned on.
* 
* Service downloads list of available packages each 20 seconds.
* @class PackageRepositoryService
* @extends AbstractService.AbstractService
* @constructor
*&#x2F;
&#x2F;** 
* Event fired after package repository is fully initialized.
* @event initialized
* @for PackageRepositoryService
*&#x2F;
&#x2F;** 
* Event fired after one package in package repository was installed or uninstalled.
* @event changed
* @for PackageRepositoryService
* @param aData {PackageEventData} Package event data.
*&#x2F;
export class PackageRepositoryService extends abstractService.AbstractService {
    &#x2F;** 
    * List of available applications.
    * @property availableApplications
    * @type {AvailablePackageData[]}
    * @private
    *&#x2F;
    private availableApplications: AvailablePackageData[] = [];
    &#x2F;** 
    * List of available categories.
    * @property categories
    * @type {CategoryData[]}
    * @private
    *&#x2F;
    private categories: CategoryData[];
    &#x2F;** 
    * Indicates if installation of package is running. Due to unzipping library limitations current system is allowed to one installation at time only.
    * @property runningInstallation
    * @type {Boolean}
    * @private
    *&#x2F;
    private runningInstallation: bool = false;
    &#x2F;** 
    * List of available car themes.
    * @property carThemes
    * @type {PackageRepositoryOptions.ThemeData[]}
    * @private
    *&#x2F;
    public carThemes: ThemeData[] = [];
    &#x2F;** 
    * List of available user themes.
    * @property userThemes
    * @type {PackageRepositoryOptions.ThemeData[]}
    * @private
    *&#x2F;
    public userThemes: ThemeData[] = [];

    &#x2F;** 
    * @method constructor
    * @param packageRepository {PackageRepositoryService.PackageRepositoryOptions} Instance of &#x60;PackageRepositoryService&#x60;
    *&#x2F;
    constructor (private options: PackageRepositoryOptions) {
        super({
            name: &quot;PackageRepository&quot;,
            endpointName: &quot;packageRepository&quot;,
            description: &quot;Package repository&quot;,
            apiClassName: &quot;PackageRepository&quot;,
            indexView: &quot;packageRepository&quot;
        });

        this.categories = [{
            id: &quot;music_and_audio&quot;,
            description: &quot;&quot;,
            name: &quot;Media&quot;,
            url: &quot;&#x2F;PackageRepository&#x2F;category?id=music_and_audio&quot;
        }, {
            id: &quot;utilities&quot;,
            description: &quot;&quot;,
            name: &quot;Utilities&quot;,
            url: &quot;&#x2F;PackageRepository&#x2F;category?id=utilities&quot;
        }, {
            id: &quot;user_theme&quot;,
            description: &quot;&quot;,
            name: &quot;User themes&quot;,
            url: &quot;&#x2F;PackageRepository&#x2F;category?id=user_theme&quot;
        }];

        this.logger.info(&quot;Application path: %s&quot;, this.options.baseApplicationPath);
        this.logger.info(&quot;Themes path: %s&quot;, this.options.baseThemePath);
        this.logger.info(&quot;Data path: %s&quot;, this.options.baseDataPath);
        this.logger.info(&quot;Theme silent install is: %s&quot;, this.options.doSilentInstall);
        this.logger.info(&quot;Latest packages url: %s&quot;, this.options.latestPackagesUrl);
        this.logger.info(&quot;Available packages url: %s&quot;, this.options.availablePackagesUrl);
        this.logger.info(&quot;Device name: %s&quot;, this.options.deviceName);
        this.logger.info(&quot;Engine version: %s&quot;, this.options.engineVersion);
    }

    &#x2F;** 
    * Attach this class to Express HTTP server application, initialize application repository and try to download available packages from remote source.
    * @method attachApplication
    * @param aApplication {ExpressApplication} Instance of Express application
    *&#x2F;
    attachApplication(aApplication: express.ExpressServer) {
        var self = this;

        this.actions.splice(this.actions.length, 0, {
            type: &quot;get&quot;,
            title: &quot;Get promoted applications&quot;,
            apiMethod: &quot;getPromotedApplications&quot;,
            endpoint: &quot;&#x2F;promoted&quot;,
            callback: this.getPromotedApplications
        }, {
            type: &quot;get&quot;,
            title: &quot;Get most popular applications&quot;,
            apiMethod: &quot;getPopularApplications&quot;,
            endpoint: &quot;&#x2F;popular&quot;,
            callback: this.getPopularApplications
        }, {
            type: &quot;get&quot;,
            title: &quot;Get available applications&quot;,
            apiMethod: &quot;getAvailableApplications&quot;,
            endpoint: &quot;&#x2F;available&quot;,
            callback: this.getAvailableApplications
        }, {
            type: &quot;get&quot;,
            title: &quot;Get application detail related to id specified as parameter.&quot;,
            apiMethod: &quot;getApplicationDetail&quot;,
            endpoint: &quot;&#x2F;applicationDetail&quot;,
            callback: this.getApplicationDetail,
            parameters: [{
                name: &quot;id&quot;,
                type: &quot;text&quot;,
                value: &quot;com.intel.tizen&#x2F;applicationstore&quot;
            }]
        }, {
            type: &quot;get&quot;,
            title: &quot;Get category related to id specified as parameter.&quot;,
            apiMethod: &quot;getCategoryApplications&quot;,
            endpoint: &quot;&#x2F;category&quot;,
            callback: this.getCategory,
            parameters: [{
                name: &quot;id&quot;,
                type: &quot;text&quot;,
                value: &quot;utilities&quot;
            }]
        }, {
            type: &quot;get&quot;,
            title: &quot;Get list of categories&quot;,
            apiMethod: &quot;getCategories&quot;,
            endpoint: &quot;&#x2F;categories&quot;,
            callback: this.getCategories
        }, {
            type: &quot;get&quot;,
            title: &quot;Get image from remote Package Repository&quot;,
            endpoint: &quot;&#x2F;image&quot;,
            callback: this.getImage
        }, {
            type: &quot;post&quot;,
            title: &quot;Install from URL&quot;,
            endpoint: &quot;&#x2F;installFromUrl&quot;,
            callback: this.installFromUrl,
            parameters: [{
                name: &quot;url&quot;,
                type: &quot;text&quot;,
                value: &quot;http:&#x2F;&#x2F;80.242.18.56:8080&#x2F;application-homescreen.wgt&quot;
            }]
        }, {
            type: &quot;post&quot;,
            title: &quot;Install&quot;,
            endpoint: &quot;&#x2F;install&quot;,
            apiMethod: &quot;install&quot;,
            callback: this.install,
            parameters: [{
                name: &quot;id&quot;,
                type: &quot;text&quot;,
                value: &quot;http:&#x2F;&#x2F;com.intel.tizen&#x2F;store&quot;
            }]
        }, {
            type: &quot;post&quot;,
            title: &quot;Uninstall&quot;,
            endpoint: &quot;&#x2F;uninstall&quot;,
            apiMethod: &quot;uninstall&quot;,
            callback: this.uninstall,
            parameters: [{
                name: &quot;id&quot;,
                type: &quot;text&quot;,
                value: &quot;http:&#x2F;&#x2F;com.intel.tizen&#x2F;store&quot;
            }]
        });

        super.attachApplication(aApplication);
        this.on(&quot;initialized&quot;, this.__checkForAvailableApplications);

        fs.readFile(path.join(this.options.baseDataPath, &quot;available.json&quot;), function (err, data) {
            if (!err) {
                var available = &lt;AvailablePackageData[]&gt; JSON.parse(data.toString());
                self.logger.info(&quot;Available package data for %d applications loaded.&quot;, available.length);
                available.map(function (value) { self.availableApplications.push(value); });
            }
            else
                self.logger.error(err);

            fs.readdir(self.options.baseApplicationPath, function (appError, files) {
                if (!appError) {
                    files.map(function (value) { self.__linkApplication(value); });
                } else
                    self.logger.error(appError);

                self.logger.info(&quot;Applications loaded &amp; detected ...&quot;);
                self.emit(&quot;initialized&quot;, {});
            });
        });

        this.__loadThemes();
    }

    &#x2F;**
    * Get currently selected car theme.
    * @method __getCarTheme
    * @return {PackageRepositoryService.ThemeData}
    *&#x2F;
    __getCarTheme(): ThemeData {
        var selectedCarTheme;

        this.carThemes.forEach(function (aItem) {
            selectedCarTheme = aItem.selected ? aItem : selectedCarTheme;
        });

        return selectedCarTheme;
    }

    &#x2F;**
    * Get currently selected user theme.
    * @method __getCarTheme
    * @return {PackageRepositoryService.ThemeData}
    *&#x2F;
    __getUserTheme(): ThemeData {
        var selectedUserTheme;

        this.userThemes.forEach(function (aItem) {
            selectedUserTheme = aItem.selected ? aItem : selectedUserTheme;
        });

        return selectedUserTheme;
    }

    &#x2F;**
    * Loads installed themes from filesystem in directory defined in &#x60;PackageRepositoryOptions.baseThemePath&#x60;. and selects first one if none is selected.
    * @method __loadThemes
    * @private
    *&#x2F;
    __loadThemes() {
        var self = this;
        var selectedCarTheme = this.__getCarTheme(), selectedUserTheme = this.__getUserTheme();

        this.carThemes = [];
        this.userThemes = [];

        fs.readdirSync(this.options.baseThemePath).forEach(function (aManufacturerItem) {
            var manufacturerThemePath = path.join(self.options.baseThemePath, aManufacturerItem);

            fs.readdirSync(manufacturerThemePath).forEach(function (aThemeItem) {
                var themeId = aManufacturerItem + &quot;&#x2F;&quot; + aThemeItem;
                var themePath = path.join(manufacturerThemePath, aThemeItem);
                var themeJson = path.join(themePath, &quot;theme.json&quot;);

                if (fs.existsSync(themeJson)) {
                    var themeData = JSON.parse(fs.readFileSync(themeJson).toString());
                    var isUserTheme = themeData.type === &quot;user&quot;;
                    var themeArray: ThemeData[] = isUserTheme ? self.userThemes : self.carThemes;
                    var selectedTheme: ThemeData = isUserTheme ? selectedUserTheme : selectedCarTheme;
                    themeData.iconUrl = util.format(&quot;%s&#x2F;icon?id=%s&quot;, &quot;&#x2F;themeengine&quot;, themeData.id);

                    themeData.selected = selectedTheme ? selectedTheme.id == themeData.id : false;
                    themeArray.push(themeData);

                    self.logger.info(&quot;Found theme &#x27;%s&#x27;&quot;, themeId);
                } else {
                    self.logger.warn(&quot;Theme definition file &#x27;%s&#x27; was not found, ignoring theme &#x27;%s&#x27;&quot;, themeJson, themeId);
                }
            });
        });

        &#x2F;&#x2F; Make sure that some theme is selected
        selectedCarTheme = this.__getCarTheme(), selectedUserTheme = this.__getUserTheme();

        if (!selectedCarTheme &amp;&amp; this.carThemes.length &gt; 0) this.carThemes[0].selected = true;
        if (!selectedUserTheme &amp;&amp; this.userThemes.length &gt; 0) this.userThemes[0].selected = true;
    }

    &#x2F;**
    * Get currently installed applications from filesystem in directory defined in &#x60;PackageRepositoryOptions.baseApplicationPath&#x60;.
    * @method getInstalledApps
    * @return {PackageRepositoryService.InstalledPackageData[]}
    *&#x2F;
    getInstalledApps(): InstalledPackageData[] {
        this.logger.info(&quot;Getting current applications from: %s&quot;, this.options.baseApplicationPath);
        var applications: InstalledPackageData[] = [];
        var appDirs = fs.readdirSync(this.options.baseApplicationPath);

        for (var i in appDirs) {
            try {
                var appDir = appDirs[i];
                if (typeof appDir == &quot;string&quot;) {
                    var applicationDirectory = path.join(this.options.baseApplicationPath, appDir);
                    var configFile = path.join(applicationDirectory, &quot;config.xml&quot;);
                    if (fs.existsSync(configFile)) {
                        var etree = elementtree.parse(fs.readFileSync(configFile).toString());
                        var itemId = etree.find(&quot;.&#x2F;&quot;).attrib.id;

                        applications.push({
                            id: itemId,
                            version: etree.find(&quot;.&#x2F;&quot;).attrib.version,
                            show: true,
                            name: etree.findtext(&quot;.&#x2F;name&quot;),
                            iconPath: etree.find(&quot;.&#x2F;icon&quot;).attrib.src,
                            __applicationDirectory: appDir
                        });

                        this.availableApplications.forEach(function (aItem) {
                            if (aItem.id == itemId) {
                                aItem.installed = true;
                                return false;
                            }
                        });

                    } else {
                        this.logger.warn(&quot;Config.xml file for application %s not found, skipping ...&quot;, appDir);
                    }
                }
            } catch (exp) {
                this.logger.error(exp);
            }
        }

        return applications;
    };

    &#x2F;**
    * &#x60;[GET] &#x2F;image&#x60; Get image from remote Package Repository (proxy calls)
    * @method getImage
    * @param path {String} Relative path to remote Package Repository.
    * @return {ImageStream} Icon binary stream.
    *&#x2F;
    getImage(aRequest: express.ExpressServerRequest, aResponse: express.ExpressServerResponse) {
        var redirect = url.resolve(this.options.availablePackagesUrl, aRequest.query.path);
        this.logger.info(&quot;Loading remote image from %s&quot;, redirect);

        var streamer = request({
            url: redirect,
            headers: this.__getHeaders(),
        });

        streamer.addListener(&#x27;response&#x27;, function (res: any) {
            aResponse.header(&#x27;Content-Type&#x27;, res.headers[&quot;content-type&quot;]);
        });
        streamer.addListener(&#x27;data&#x27;, function (chunk) { aResponse.write(chunk, &quot;binary&quot;); });
        streamer.addListener(&#x27;end&#x27;, function () { aResponse.end(); });
    }

    &#x2F;**
    * Get authentication headers for calls to remote Package Repository.
    * @method __getHeaders
    * @private
    * @return {Object}
    *&#x2F;
    __getHeaders() {
        return {
            &quot;X-Device-Name&quot;: this.options.deviceName,
            &quot;user-agent&quot;: util.format(&quot;Mozilla&#x2F;5.0 (%s %s, %s, %s) NodeJS&#x2F;%s IviEngine&#x2F;%s&quot;, os.type(), os.release(), os.platform(), os.arch(), process.version, this.options.engineVersion),
            &quot;Authorization&quot;: &quot;Basic aW50ZWw6VGlaM040NTYh&quot; &#x2F;&#x2F; intel:TiZ3N456!
        };
    }

    &#x2F;**
    * Updates list of available applications from remote Package repository URL defined by &#x60;PackageRepositoryOptions.availablePackagesUrl&#x60;.
    * @method __checkForAvailableApplications
    * @private
    *&#x2F;
    __checkForAvailableApplications() {
        var self = this;
        this.logger.info(&quot;Checking app&#x2F;theme repositories from: %s&quot;, this.options.availablePackagesUrl);

        var req = request({
            url: this.options.availablePackagesUrl,
            headers: this.__getHeaders(),
        }, function (error, response, body) {
            try {
                self.logger.info(&quot;Download status code %d, error: %s &quot;, response ? response.statusCode : 0, error);
                if (!error) {
                    self.availableApplications = JSON.parse(body);

                    &#x2F;&#x2F; Remap images path to remote server - in future also cache
                    self.availableApplications.forEach(function (application) {
                        application.iconUrl = util.format(&quot;%s&#x2F;image?path=%s&quot;, self.basePath, encodeURIComponent(application.iconUrl));
                        application.screenshots = application.screenshots.map(function (screenshot) { return util.format(&quot;%s&#x2F;image?path=%s&quot;, self.basePath, encodeURIComponent(screenshot)); });
                    });

                } else self.logger.error(&quot;Error downloading available packages&quot;, error);
            } catch (ex) {
                self.logger.error(&quot;Exception downloading available packages&quot;, error);
            } finally {
                self.__checkForApplicationUpdates();
            }
        });
    }

    &#x2F;**
    * Updates list of possible applications updates from remote Package repository URL defined by &#x60;PackageRepositoryOptions.latestPackagesUrl&#x60;.
    * @method __checkForAvailableApplications
    * @private
    *&#x2F;
    __checkForApplicationUpdates() {
        var self = this;
        this.logger.info(&quot;Checking latest app&#x2F;theme packages from: %s&quot;, this.options.latestPackagesUrl);
        var installedApplication: any[] = this.getInstalledApps();
        this.carThemes.forEach(function (theme) { installedApplication.push(theme); });
        this.userThemes.forEach(function (theme) { installedApplication.push(theme); });

        request({
            url: this.options.latestPackagesUrl,
            headers: this.__getHeaders(),
        }, function (error, response, body) {
            try {
                self.logger.info(&quot;Download status code %d, error: %s &quot;, response ? response.statusCode : 0, error);
                if (!error) {
                    var data = JSON.parse(body.toString());
                    var installableApplications: AvailablePackageData[] = [];

                    data.forEach(function (remoteItem) {
                        if (remoteItem.id) {
                            var found = false;

                            installedApplication.forEach(function (installedItem) {
                                if (installedItem.id === remoteItem.id) {
                                    self.logger.debug(&quot;%s local v.%s, remote v.%s&quot;, installedItem.id, installedItem.version, remoteItem.version);
                                    if (remoteItem.version &gt; installedItem.version) {
                                        self.logger.info(&quot;Updating item %s [version %s vs. %s]&quot;, remoteItem.id, installedItem.version, remoteItem.version);
                                        installableApplications.push(remoteItem);
                                    }
                                    found = true;
                                    return true;
                                }
                            });

                            if (!found) { &#x2F;&#x2F; Mark also ones that are not on system
                                installableApplications.push(remoteItem);
                            }
                        }
                    });

                    installableApplications.forEach(function (aItem) {
                        self.logger.info(&quot;Application %s have new version %s&quot;, aItem.id, aItem.version);
                        if (self.options.doSilentInstall &amp;&amp; aItem.silentInstall) {
                            self.logger.info(&quot;Performing silent install&quot;);
                            self.__install(aItem.id, function () { });
                        }
                    });
                }

                &#x2F;&#x2F; ToDO: removal of unavailable packages
            } catch (ex) {
                self.logger.error(ex);
            } finally {
                setTimeout(function () {
                    self.__checkForAvailableApplications();
                }, 20000);
            }
        });
    }

    &#x2F;**
    * Links application name from &#x60;config.xml&#x60; to real filesystem directory
    * @method __linkApplication
    * @param aApplicationName {String} Name of application
    * @private
    *&#x2F;
    __linkApplication(aApplicationName: string) {
        var appPath = path.join(this.options.baseApplicationPath, aApplicationName);
        var appName = &quot;&#x2F;application&#x2F;&quot; + aApplicationName;
        this.logger.info(&quot;Linking %s to %s&quot;, appName, appPath);
        this.applicationRoot.use(appName, express.static(appPath));
    }

    &#x2F;**
    * &#x60;[GET] &#x2F;promoted&#x60; Returns list of promoted applications
    * @method getPromotedApplications
    * @return {PackageRepositoryService.AvailablePackageData[]}
    *&#x2F;
    getPromotedApplications(aRequest: express.ExpressServerRequest, aResponse: express.ExpressServerResponse) {
        var retValues: AvailablePackageData[] = [];
        this.availableApplications.forEach(function (element, index) {
            if (element.isPromoted) {
                retValues.push(element);
            }
        });

        if (retValues.length === 0) {
            var errorObj = {
                error: &#x27;There is no such promoted application in repository&#x27;
            };
            aResponse.json(errorObj);
        } else {
            aResponse.json(retValues);
        }
    }

    &#x2F;**
    * Finds out real remote endpoint from ID and installs package from remote repository.
    * @method __install
    * @param aId {String} ID of package
    * @param aCallback {Callback(error, response)} Callback after operation was completed with error or success status
    * @private
    *&#x2F;
    __install(aId: string, aCallback) {
        var self = this;
        var downloadUrl = &quot;http:&#x2F;&#x2F;intel:TiZ3N456!@80.242.18.56:8080&#x2F;download&#x2F;application-&quot; + aId.split(&quot;&#x2F;&quot;).pop() + &quot;.wgt&quot;;
        this.availableApplications.forEach(function (aItem) {
            if (aItem.id == aId) {
                if (!!aItem.downloadUrl) {
                    downloadUrl = url.resolve(self.options.latestPackagesUrl, aItem.downloadUrl);
                } else {
                    downloadUrl = aItem.category_id === &quot;user_themes&quot; ? &quot;http:&#x2F;&#x2F;80.242.18.56&#x2F;idcs&#x2F;services&#x2F;themes&#x2F;downloadTheme?themeId=&quot; + aId : downloadUrl;
                }
            }
        });

        this.logger.info(&quot;Download url: %s&quot;, downloadUrl);
        this.__installApplication(downloadUrl, aCallback);
    };

    &#x2F;**
    * &#x60;[POST] &#x2F;install&#x60; Installs package from remote Package Repository by package ID
    * @method install
    * @param id {String} ID of package
    *&#x2F;
    install(aRequest: express.ExpressServerRequest, aResponse: express.ExpressServerResponse) {
        var applicationId = aRequest.body.id;
        this.logger.info(&quot;Attempt to install %s&quot;, applicationId);
        this.__install(applicationId, function (error, response) {
            aResponse.json({
                response: response,
                error: !!error ? error.message : error
            });
        });
    };

    &#x2F;**
    * Installs package from remote repository.
    * @method __installApplication
    * @param aDownloadUrl {String} Download URL of package
    * @param aCallback {Callback(error, response)} Callback after operation was completed with error or success status
    * @private
    *&#x2F;
    __installApplication(aDownloadUrl: string, aCallback: (error: any, response?: any) =&gt; void ) {
        if (this.runningInstallation) {
            this.logger.warn(&quot;Another installation is running, skipping call ...&quot;);
            aCallback(&quot;Another installation in progress&quot;);
        }
        else { 
            this.runningInstallation = true;
            var self = this;
            var callback = function (error: any, response?: any) {
                self.runningInstallation = false;
                aCallback(error, response);
            }

            this.logger.info(&quot;Downloading package from: %s&quot;, aDownloadUrl);
            var tempBaseName = util.format(&quot;download_%d&quot;, new Date().getTime());
            var tempFile = path.join(os.tmpDir(), tempBaseName + &quot;.zip&quot;);

            var req = request({ url: aDownloadUrl, headers: this.__getHeaders() }, function (error, response, body) {
                self.logger.info(&quot;Download status %d, error: %s&quot;, response ? response.statusCode : 0, error);
                try {
                    if (!error &amp;&amp; response.statusCode == 200) {
                        fs.readFile(tempFile, function (err, data) {
                            if (err) callback(err);
                            else { 
                                var isApplication: bool, outputDir: string, itemId: string;

                                zip.Reader(data).forEach(function (entry) {
                                    var entryName: string = entry.getName();
                                    if (entryName === &quot;theme.json&quot;) {
                                        self.logger.info(&quot;Found theme.json file, parsing ...&quot;);
                                        try {
                                            isApplication = false;
                                            itemId = JSON.parse(entry.getData().toString()).id.replace(&quot;http:&#x2F;&#x2F;&quot;, &quot;&quot;);
                                            outputDir = path.join(self.options.baseThemePath, itemId);
                                            return true;
                                        } catch (ex) {
                                            callback(ex);
                                        }
                                    }

                                    if (entryName === &quot;config.xml&quot;) {
                                        self.logger.info(&quot;Found config.xml file, parsing ...&quot;);
                                        try {
                                            var etree = elementtree.parse(entry.getData().toString());
                                            isApplication = true;
                                            itemId = etree.find(&quot;.&#x2F;&quot;).attrib.id.toLowerCase().replace(&quot;http:&#x2F;&#x2F;&quot;, &quot;&quot;).replace(&quot;&#x2F;&quot;, &quot;_&quot;);
                                            outputDir = path.join(self.options.baseApplicationPath, itemId);
                                            return true;
                                        } catch (ex) {
                                            callback(ex);
                                        }
                                    }
                                });

                                if (!!outputDir &amp;&amp; !!itemId) {
                                    try {
                                        self.logger.info(&quot;Unzipping package to dir %s&quot;, outputDir);
                                        zip.Reader(data).forEach(function (entry) {
                                            var entryName: string = entry.getName();
                                            var outputPath = path.join(outputDir, entryName);
                                            var directoryName = path.dirname(outputPath);
                                            if (!fs.existsSync(directoryName)) {
                                                self.logger.debug(&quot;Creating directory %s&quot;, directoryName);
                                                mkdirp.sync(directoryName);
                                            }

                                            self.logger.debug(&quot;Writing %s&quot;, outputPath);
                                            fs.writeFileSync(outputPath, entry.getData());
                                        });

                                        if (isApplication) {
                                            self.__linkApplication(itemId);

                                            self.emit(&quot;changed&quot;, {
                                                application: itemId,
                                                type: &quot;installedApplication&quot;
                                            });
                                        } else {
                                            self.emit(&quot;changed&quot;, {
                                                theme: &quot;http:&#x2F;&#x2F;&quot; + itemId,
                                                type: &quot;installedTheme&quot;
                                            });
                                        }

                                        callback(null, &quot;OK&quot;);
                                    }
                                    catch (ex) {
                                        self.logger.error(&quot;Exception occured during unpacking&quot;, ex);
                                    }
                                    finally {
                                        self.logger.info(&quot;Removing file %s&quot;, tempFile);
                                        fs.unlinkSync(tempFile);
                                    }
                                } else {
                                    callback(&quot;Downloaded package is not an application or theme, ignoring ...&quot;);
                                } 
              }
                        });
                    }
                } catch (ex) {
                    callback(ex);
                }
            });

            var contentLength = 0, received = 0, lastTick = new Date().getTime();

            req.on(&quot;response&quot;, function (res) {
                contentLength = parseInt(res.headers[&quot;content-length&quot;], 10);
            });
            req.on(&quot;data&quot;, function (data) {
                received += data.length;
                var progress = received &#x2F; contentLength;
                var currentTick = new Date().getTime();
                if ((currentTick - lastTick) &gt; 2000) {
                    self.logger.debug(&quot;%s: %d kB downloaded&quot;, tempFile, Math.round(received &#x2F; 1024));
                    lastTick = currentTick;
                }
            });

            req.pipe(fs.createWriteStream(tempFile)); 
        }
    }

    &#x2F;**
    * &#x60;[GET] &#x2F;popular&#x60; Returns list of popular applications
    * @method getPopularApplications
    * @return {PackageRepositoryService.AvailablePackageData[]}
    *&#x2F;
    getPopularApplications(aRequest: express.ExpressServerRequest, aResponse: express.ExpressServerResponse) {
        var retValues = [];
        this.availableApplications.forEach(function (element, index) {
            if (String(element.isPopular) == &quot;true&quot;) {
                retValues.push(element);
            }
        });

        if (retValues.length === 0) {
            var errorObj = {
                error: &#x27;There is no popular application in repository&#x27;
            };
            aResponse.json(errorObj);
        } else {
            aResponse.json(retValues);
        }
    }

    &#x2F;**
    * &#x60;[GET] &#x2F;available&#x60; Returns list of all available applications
    * @method getAvailableApplications
    * @return {PackageRepositoryService.AvailablePackageData[]}
    *&#x2F;
    getAvailableApplications(aRequest: express.ExpressServerRequest, aResponse: express.ExpressServerResponse) {
        aResponse.json(this.availableApplications);
    }

    &#x2F;**
    * &#x60;[GET] &#x2F;applicationDetail&#x60; Returns detailed information of one application
    * @method getApplicationDetail
    * @param id {String} Package ID
    * @return {PackageRepositoryService.AvailablePackageData}
    *&#x2F;
    getApplicationDetail(aRequest: express.ExpressServerRequest, aResponse: express.ExpressServerResponse) {
        var id = aRequest.param(&quot;id&quot;);
        var result: any;

        this.logger.info(&quot;Requesting application detail for %s&quot;, id);

        if (!!id) {
            result = this.availableApplications.filter(function (app) {
                return app.id == id;
            });
            result = result.length &gt; 0 ? result.pop() : undefined;
            if (!result) {
                result = { error: &#x27;There is no such application in repository&#x27; };
            }
        }
        else {
            result = { error: &#x27;Missing id parameter&#x27; };
        }

        aResponse.json(result);
    };

    &#x2F;**
    * &#x60;[GET] &#x2F;category&#x60; Returns packages for specified category id
    * @method getCategory
    * @param id {String} Category ID
    * @return {PackageRepositoryService.AvailablePackageData[]}
    *&#x2F;
    getCategory(aRequest: express.ExpressServerRequest, aResponse: express.ExpressServerResponse) {
        var id = aRequest.param(&#x27;id&#x27;);
        if (id === undefined) {
            var errorObj = {
                error: &#x27;Missing id parameter&#x27;
            };
            aResponse.json(errorObj);
            return;
        }

        var retValues = [];
        this.availableApplications.forEach(function (element, index) {
            if (String(element.category_id) == String(id)) {
                retValues.push(element);
                &#x2F;&#x2F;detail = element;
            }
        });

        if (retValues.length === 0) {
            var errorObj = {
                error: &#x27;There is no such category in repository&#x27;
            };
            aResponse.json(errorObj);
        } else {
            aResponse.json(retValues);
        }
    };

    &#x2F;**
    * &#x60;[GET] &#x2F;category&#x60; Returns available categories
    * @method getCategories
    * @return {PackageRepositoryService.CategoryData[]}
    *&#x2F;
    getCategories(aRequest: express.ExpressServerRequest, aResponse: express.ExpressServerResponse) {
        aResponse.json(this.categories);
    };

    &#x2F;**
    * &#x60;[POST] &#x2F;installFromUrl&#x60; Installs package from specified URL
    * @method installFromUrl
    * @param url {String} URL of package location
    *&#x2F;
    installFromUrl(aRequest: express.ExpressServerRequest, aResponse: express.ExpressServerResponse) {
        var self = this;
        var downloadUrl = aRequest.body.url;

        this.__installApplication(downloadUrl, function (error, response? ) {
            aResponse.json({ response: response, error: error });
        });
    };

    &#x2F;**
    * Recursively deletes specified folder.
    * @method __deleteFolderRecursive
    * @param path {String} Folder to delete
    *&#x2F;
    __deleteFolderRecursive(path: string) {
        var self = this;
        var files = [];
        if (fs.existsSync(path)) {
            files = fs.readdirSync(path);
            files.forEach(function (file, index) {
                var curPath = path + &quot;&#x2F;&quot; + file;
                if (fs.statSync(curPath).isDirectory()) { &#x2F;&#x2F; recurse
                    self.__deleteFolderRecursive(curPath);
                } else { &#x2F;&#x2F; delete file
                    fs.unlinkSync(curPath);
                }
            });
            fs.rmdirSync(path);
        }
    };

    
    &#x2F;**
    * &#x60;[POST] &#x2F;uninstall&#x60; Uninstalls package from local filesystem
    * @method uninstall
    * @param id {String} ID of package
    *&#x2F;
    uninstall(aRequest: express.ExpressServerRequest, aResponse: express.ExpressServerResponse) {
        var self = this;
        var result: InstalledPackageData[] = [];
        var applicationId: string = aRequest.body.id;

        this.getInstalledApps().forEach(function (aItem) {
            if (aItem.id == applicationId) {
                try {
                    self.logger.info(&quot;Uninstalling application %s&quot;, applicationId);
                    self.__deleteFolderRecursive(path.join(self.options.baseApplicationPath, aItem.__applicationDirectory));

                    result = self.getInstalledApps();
                    self.emit(&#x27;changed&#x27;, {
                        application: aItem,
                        type: &quot;uninstalled&quot;
                    });
                } catch (ex) {
                    self.logger.error(ex);
                }

                return false;
            }
        });

        aResponse.json(result);
    };
}
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
