<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\extern\node.d.ts - Intel Tizen IVI Engine</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="https:&#x2F;&#x2F;www.tizen.org&#x2F;sites&#x2F;all&#x2F;themes&#x2F;tizen_theme&#x2F;logo.png" title="Intel Tizen IVI Engine"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.2012105.151454</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/AbstractService.AbstractService.html">AbstractService.AbstractService</a></li>
            
                <li><a href="..&#x2F;classes/AbstractService.AbstractServiceOptions.html">AbstractService.AbstractServiceOptions</a></li>
            
                <li><a href="..&#x2F;classes/AbstractService.EndpointAction.html">AbstractService.EndpointAction</a></li>
            
                <li><a href="..&#x2F;classes/AbstractService.EndpointActionParameter.html">AbstractService.EndpointActionParameter</a></li>
            
                <li><a href="..&#x2F;classes/ApiEndpointBase.ApiEndpointBase.html">ApiEndpointBase.ApiEndpointBase</a></li>
            
                <li><a href="..&#x2F;classes/AudioService.AudioService.html">AudioService.AudioService</a></li>
            
                <li><a href="..&#x2F;classes/AudioService.StatusData.html">AudioService.StatusData</a></li>
            
                <li><a href="..&#x2F;classes/CarIndicatorService.CarIndicatorService.html">CarIndicatorService.CarIndicatorService</a></li>
            
                <li><a href="..&#x2F;classes/CarIndicatorService.RandomizerData.html">CarIndicatorService.RandomizerData</a></li>
            
                <li><a href="..&#x2F;classes/CarIndicatorService.StatusData.html">CarIndicatorService.StatusData</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.AlphabetBookmark.html">com.intel.tizen.coulomb.2012.AlphabetBookmark</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.AudioPlayer.html">com.intel.tizen.coulomb.2012.AudioPlayer</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.BottomPanel.html">com.intel.tizen.coulomb.2012.BottomPanel</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.BoxCaption.html">com.intel.tizen.coulomb.2012.BoxCaption</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.ButtonControlsObj.html">com.intel.tizen.coulomb.2012.ButtonControlsObj</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.Carousel.html">com.intel.tizen.coulomb.2012.Carousel</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.Clock.html">com.intel.tizen.coulomb.2012.Clock</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.ClockPlugin.html">com.intel.tizen.coulomb.2012.ClockPlugin</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.global.html">com.intel.tizen.coulomb.2012.global</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.jQuery.html">com.intel.tizen.coulomb.2012.jQuery</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.Library.html">com.intel.tizen.coulomb.2012.Library</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.MusicLibraryFileSystem.html">com.intel.tizen.coulomb.2012.MusicLibraryFileSystem</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.progressBarPlugin.html">com.intel.tizen.coulomb.2012.progressBarPlugin</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.Settings.html">com.intel.tizen.coulomb.2012.Settings</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.Tabs.html">com.intel.tizen.coulomb.2012.Tabs</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.Themes.html">com.intel.tizen.coulomb.2012.Themes</a></li>
            
                <li><a href="..&#x2F;classes/com.intel.tizen.coulomb.2012.TopBarIcons.html">com.intel.tizen.coulomb.2012.TopBarIcons</a></li>
            
                <li><a href="..&#x2F;classes/Engine.Server.html">Engine.Server</a></li>
            
                <li><a href="..&#x2F;classes/EventSourceDispatcher.EventSourceDispatcher.html">EventSourceDispatcher.EventSourceDispatcher</a></li>
            
                <li><a href="..&#x2F;classes/EventSourceDispatcher.EventUpdateData.html">EventSourceDispatcher.EventUpdateData</a></li>
            
                <li><a href="..&#x2F;classes/HomeScreenService.HomeScreenService.html">HomeScreenService.HomeScreenService</a></li>
            
                <li><a href="..&#x2F;classes/PackageRepositoryService.AvailablePackageData.html">PackageRepositoryService.AvailablePackageData</a></li>
            
                <li><a href="..&#x2F;classes/PackageRepositoryService.CategoryData.html">PackageRepositoryService.CategoryData</a></li>
            
                <li><a href="..&#x2F;classes/PackageRepositoryService.InstalledPackageData.html">PackageRepositoryService.InstalledPackageData</a></li>
            
                <li><a href="..&#x2F;classes/PackageRepositoryService.PackageEventData.html">PackageRepositoryService.PackageEventData</a></li>
            
                <li><a href="..&#x2F;classes/PackageRepositoryService.PackageRepositoryOptions.html">PackageRepositoryService.PackageRepositoryOptions</a></li>
            
                <li><a href="..&#x2F;classes/PackageRepositoryService.PackageRepositoryService.html">PackageRepositoryService.PackageRepositoryService</a></li>
            
                <li><a href="..&#x2F;classes/PackageRepositoryService.ThemeData.html">PackageRepositoryService.ThemeData</a></li>
            
                <li><a href="..&#x2F;classes/PersistentConsole.console.html">PersistentConsole.console</a></li>
            
                <li><a href="..&#x2F;classes/ThemeEngineService.ThemeEngineService.html">ThemeEngineService.ThemeEngineService</a></li>
            
                <li><a href="..&#x2F;classes/TizenApplicationStubService.TizenApplicationStubService.html">TizenApplicationStubService.TizenApplicationStubService</a></li>
            
                <li><a href="..&#x2F;classes/UserStatusService.UserDetails.html">UserStatusService.UserDetails</a></li>
            
                <li><a href="..&#x2F;classes/UserStatusService.UserSettings.html">UserStatusService.UserSettings</a></li>
            
                <li><a href="..&#x2F;classes/UserStatusService.UserStatusService.html">UserStatusService.UserStatusService</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\extern\node.d.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;************************************************
*                                               *
*               Node.js v0.8.8 API              *
*                                               *
************************************************&#x2F;

&#x2F;************************************************
*                                               *
*                   GLOBAL                      *
*                                               *
************************************************&#x2F;
declare var process: NodeProcess;
declare var global: any;

declare var console: {
    log(...data: any[]): void;
    info(...data: any[]): void;
    error(...data: any[]): void;
    warn(...data: any[]): void;
    dir(obj: any): void;
    timeEnd(label: string): void;
    trace(label: string): void;
    assert(expression: any, ...message: string[]): void;
}

declare var __filename: string;
declare var __dirname: string;

declare function setTimeout(callback: () =&gt; void , ms: number): any;
declare function clearTimeout(timeoutId: any);
declare function setInterval(callback: () =&gt; void , ms: number): any;
declare function clearInterval(intervalId: any);

declare var require: {
    (id: string): any;
    resolve(): string;
    cache: any;
    extensions: any;
}

declare var module: {
    exports: any;
    require(id: string): any;
    id: string;
    filename: string;
    loaded: bool;
    parent: any;
    children: any[];
}

&#x2F;&#x2F; Same as module.exports
declare var exports: any;
declare var SlowBuffer: {
    new (str: string, encoding?: string): NodeBuffer;
    new (size: number): NodeBuffer;
    new (array: any[]): NodeBuffer;
    prototype: NodeBuffer;
    isBuffer(obj: any): bool;
    byteLength(string: string, encoding?: string): number;
    concat(list: NodeBuffer[], totalLength?: number): NodeBuffer;
};
declare var Buffer: {
    new (str: string, encoding?: string): NodeBuffer;
    new (size: number): NodeBuffer;
    new (array: any[]): NodeBuffer;
    prototype: NodeBuffer;
    isBuffer(obj: any): bool;
    byteLength(string: string, encoding?: string): number;
    concat(list: NodeBuffer[], totalLength?: number): NodeBuffer;
}

&#x2F;************************************************
*                                               *
*                   INTERFACES                  *
*                                               *
************************************************&#x2F;

interface EventEmitter {
    addListener(event: string, listener: Function);
    on(event: string, listener: Function);
    once(event: string, listener: Function): void;
    removeListener(event: string, listener: Function): void;
    removeAllListeners(event: string): void;
    setMaxListeners(n: number): void;
    listeners(event: string): { Function; }[];
    &#x2F;&#x2F;emit(event: string, arg1?: any, arg2?: any): void;
	emit(event: string, ...args: any[]): void;
}

interface WritableStream extends EventEmitter {
    writable: bool;
    write(str: string, encoding?: string, fd?: string): bool;
    write(buffer: NodeBuffer): bool;
    end(): void;
    end(str: string, enconding: string): void;
    end(buffer: NodeBuffer): void;
    destroy(): void;
    destroySoon(): void;
}

interface ReadableStream extends EventEmitter {
    readable: bool;
    setEncoding(encoding: string): void;
    pause(): void;
    resume(): void;
    destroy(): void;
    pipe(destination: WritableStream, options?: { end?: bool; }): void;
}

interface NodeProcess extends EventEmitter {
    stdout: WritableStream;
    stderr: WritableStream;
    stdin: ReadableStream;
    argv: string[];
    execPath: string;
    abort(): void;
    chdir(directory: string): void;
    cwd(): void;
    env: any;
    exit(code?: number): void;
    getgid(): number;
    setgid(id: number): void;
    getuid(): number;
    setuid(id: number): void;
    version: string;
    versions: { http_parser: string; node: string; v8: string; ares: string; uv: string; zlib: string; openssl: string; };
    config: {
        target_defaults: {
            cflags: any[];
            default_configuration: string;
            defines: string[];
            include_dirs: string[];
            libraries: string[];
        };
        variables: {
        clang: number;
        host_arch: string;
        node_install_npm: bool;
        node_install_waf: bool;
        node_prefix: string;
        node_shared_openssl: bool;
        node_shared_v8: bool;
        node_shared_zlib: bool;
        node_use_dtrace: bool;
        node_use_etw: bool;
        node_use_openssl: bool;
        target_arch: string;
        v8_no_strict_aliasing: number;
        v8_use_snapshot: bool;
        visibility: string;
    };
    };
    kill(pid: number, signal?: string): void;
    pid: number;
    title: string;
    arch: string;
    platform: string;
    memoryUsage(): { rss: number; heapTotal; number; heapUsed: number; };
    nextTick(callback: Function): void;
    umask(mask?: number): number;
    uptime(): number;
    hrtime(): number[];
}

&#x2F;&#x2F; Buffer class
interface NodeBuffer {
    [index: number]: number;
    write(string: string, offset?: number, length?: number, encoding?: string): number;
    toString(encoding?: string, start?: number, end?: number): string;
    length: number;
    copy(targetBuffer: NodeBuffer, targetStart?: number, sourceStart?: number, sourceEnd?: number): void;
    slice(start?: number, end?: number): NodeBuffer;
    readUInt8(offset: number, noAsset?: bool): number;
    readUInt16LE(offset: number, noAssert?: bool): number;
    readUInt16BE(offset: number, noAssert?: bool): number;
    readUInt32LE(offset: number, noAssert?: bool): number;
    readUInt32BE(offset: number, noAssert?: bool): number;
    readInt8(offset: number, noAssert?: bool): number;
    readInt16LE(offset: number, noAssert?: bool): number;
    readInt16BE(offset: number, noAssert?: bool): number;
    readInt32LE(offset: number, noAssert?: bool): number;
    readInt32BE(offset: number, noAssert?: bool): number;
    readFloatLE(offset: number, noAssert?: bool): number;
    readFloatBE(offset: number, noAssert?: bool): number;
    readDoubleLE(offset: number, noAssert?: bool): number;
    readDoubleBE(offset: number, noAssert?: bool): number;
    writeUInt8(value: number, offset: number, noAssert?: bool): void;
    writeUInt16LE(value: number, offset: number, noAssert?: bool): void;
    writeUInt16BE(value: number, offset: number, noAssert?: bool): void;
    writeUInt32LE(value: number, offset: number, noAssert?: bool): void;
    writeUInt32BE(value: number, offset: number, noAssert?: bool): void;
    writeInt8(value: number, offset: number, noAssert?: bool): void;
    writeInt16LE(value: number, offset: number, noAssert?: bool): void;
    writeInt16BE(value: number, offset: number, noAssert?: bool): void;
    writeInt32LE(value: number, offset: number, noAssert?: bool): void;
    writeInt32BE(value: number, offset: number, noAssert?: bool): void;
    writeFloatLE(value: number, offset: number, noAssert?: bool): void;
    writeFloatBE(value: number, offset: number, noAssert?: bool): void;
    writeDoubleLE(value: number, offset: number, noAssert?: bool): void;
    writeDoubleBE(value: number, offset: number, noAssert?: bool): void;
    fill(value: any, offset?: number, end?: number): void;
    INSPECT_MAX_BYTES: number;
}

&#x2F;************************************************
*                                               *
*                   MODULES                     *
*                                               *
************************************************&#x2F;
declare module &quot;querystring&quot; {
    export function stringify(obj: any, sep?: string, eq?: string): string;
    export function parse(str: string, sep?: string, eq?: string, options?: { maxKeys?: number; }): any;
    export function escape(): any;
    export function unescape(): any;
}

declare module &quot;events&quot; {
    export interface NodeEventEmitter {
        addListener(event: string, listener: Function);
        on(event: string, listener: Function): any;
        once(event: string, listener: Function): void;
        removeListener(event: string, listener: Function): void;
        removeAllListener(event: string): void;
        setMaxListeners(n: number): void;
        listeners(event: string): { Function; }[];
        emit(event: string, arg1?: any, arg2?: any): void;
    }

    export var EventEmitter: NodeEventEmitter;
}

declare module &quot;http&quot; {
    import events = module(&quot;events&quot;);
    import net = module(&quot;net&quot;);
    import stream = module(&quot;stream&quot;);

    export interface Server extends events.NodeEventEmitter {
        listen(port: number, hostname?: string, backlog?: number, callback?: Function): void;
		listen(port: number, hostname?: number, callback?: Function): void;
        listen(path: string, callback?: Function): void;
        listen(handle: any, listeningListener?: Function): void;
        close(cb?: any): void;
        maxHeadersCount: number;
    }
    export interface ServerRequest extends events.NodeEventEmitter, stream.ReadableStream {
        method: string;
        url: string;
        headers: string;
        trailers: string;
        httpVersion: string;
        setEncoding(encoding?: string): void;
        pause(): void;
        resume(): void;
        connection: net.NodeSocket;
    }
    export interface ServerResponse extends events.NodeEventEmitter, stream.WritableStream {
        &#x2F;&#x2F; Extended base methods
        write(str: string, encoding?: string, fd?: string): bool;
        write(buffer: NodeBuffer): bool;

        writeContinue(): void;
        writeHead(statusCode: number, reasonPhrase?: string, headers?: any): void;
        writeHead(statusCode: number, headers?: any): void;
        statusCode: number;
        setHeader(name: string, value: string): void;
        sendDate: bool;
        getHeader(name: string): string;
        removeHeader(name: string): void;
        write(chunk: any, encoding?: string): any;
        addTrailers(headers: any): void;
        end(data?: any, encoding?: string): void;
    }
    export interface ClientRequest extends events.NodeEventEmitter, stream.WritableStream {
        &#x2F;&#x2F; Extended base methods
        write(str: string, encoding?: string, fd?: string): bool;
        write(buffer: NodeBuffer): bool;

        write(chunk: any, encoding?: string): void;
        end(data?: any, encoding?: string): void;
        abort(): void;
        setTimeout(timeout: number, callback?: Function): void;
        setNoDelay(noDelay?: Function): void;
        setSocketKeepAlive(enable?: bool, initialDelay?: number): void;
    }
    export interface ClientResponse extends events.NodeEventEmitter, stream.ReadableStream {
        statusCode: number;
        httpVersion: string;
        headers: any;
        trailers: any;
        setEncoding(encoding?: string): void;
        pause(): void;
        resume(): void;
    }
    export interface Agent { maxSockets: number; sockets: any; requests: any; }

    export var STATUS_CODES;
    export function createServer(requestListener?: (request: ServerRequest, response: ServerResponse) =&gt;void ): Server;
    export function createClient(port?: number, host?: string): any;
    export function request(options: any, callback?: Function): ClientRequest;
    export function get(options: any, callback?: Function): ClientRequest;
    export var globalAgent: Agent;
}

declare module &quot;cluster&quot; {
    import child_process = module(&quot;child_process&quot;);

    export interface ClusterSettings {
        exec: string;
        args: string[];
        silent: bool;
    }
    export interface Worker {
        id: string;
        process: child_process;
        suicide: bool;
        send(message: any, sendHandle?: any): void;
        destroy(): void;
        disconnect(): void;
    }


    export var settings: ClusterSettings;
    export var isMaster: bool;
    export var isWorker: bool;
    export function setupMaster(settings?: ClusterSettings): void;
    export function fork(env?: any): Worker;
    export function disconnect(callback?: Function): void;
    export var workers: any;

    &#x2F;&#x2F; Event emitter    
    export function addListener(event: string, listener: Function): void;
    export function on(event: string, listener: Function): any;
    export function once(event: string, listener: Function): void;
    export function removeListener(event: string, listener: Function): void;
    export function removeAllListener(event: string): void;
    export function setMaxListeners(n: number): void;
    export function listeners(event: string): { Function; }[];
    export function emit(event: string, arg1?: any, arg2?: any): void;
}

declare module &quot;zlib&quot; {
    import stream = module(&quot;stream&quot;);
    export interface ZlibOptions { chunkSize?: number; windowBits?: number; level?: number; memLevel?: number; strategy?: number; dictionary?: any; }

    export interface Gzip extends stream.ReadWriteStream { }
    export interface Gunzip extends stream.ReadWriteStream { }
    export interface Deflate extends stream.ReadWriteStream { }
    export interface Inflate extends stream.ReadWriteStream { }
    export interface DeflateRaw extends stream.ReadWriteStream { }
    export interface InflateRaw extends stream.ReadWriteStream { }
    export interface Unzip extends stream.ReadWriteStream { }

    export function createGzip(options: ZlibOptions): Gzip;
    export function createGunzip(options: ZlibOptions): Gunzip;
    export function createDeflate(options: ZlibOptions): Deflate;
    export function createInflate(options: ZlibOptions): Inflate;
    export function createDeflateRaw(options: ZlibOptions): DeflateRaw;
    export function createInflateRaw(options: ZlibOptions): InflateRaw;
    export function createUnzip(options: ZlibOptions): Unzip;

    export function deflate(buf: NodeBuffer, callback: (error: Error, result) =&gt;void ): void;
    export function deflateRaw(buf: NodeBuffer, callback: (error: Error, result) =&gt;void ): void;
    export function gzip(buf: NodeBuffer, callback: (error: Error, result) =&gt;void ): void;
    export function gunzip(buf: NodeBuffer, callback: (error: Error, result) =&gt;void ): void;
    export function inflate(buf: NodeBuffer, callback: (error: Error, result) =&gt;void ): void;
    export function inflateRaw(buf: NodeBuffer, callback: (error: Error, result) =&gt;void ): void;
    export function unzip(buf: NodeBuffer, callback: (error: Error, result) =&gt;void ): void;

    &#x2F;&#x2F; Constants
    export var Z_NO_FLUSH: number;
    export var Z_PARTIAL_FLUSH: number;
    export var Z_SYNC_FLUSH: number;
    export var Z_FULL_FLUSH: number;
    export var Z_FINISH: number;
    export var Z_BLOCK: number;
    export var Z_TREES: number;
    export var Z_OK: number;
    export var Z_STREAM_END: number;
    export var Z_NEED_DICT: number;
    export var Z_ERRNO: number;
    export var Z_STREAM_ERROR: number;
    export var Z_DATA_ERROR: number;
    export var Z_MEM_ERROR: number;
    export var Z_BUF_ERROR: number;
    export var Z_VERSION_ERROR: number;
    export var Z_NO_COMPRESSION: number;
    export var Z_BEST_SPEED: number;
    export var Z_BEST_COMPRESSION: number;
    export var Z_DEFAULT_COMPRESSION: number;
    export var Z_FILTERED: number;
    export var Z_HUFFMAN_ONLY: number;
    export var Z_RLE: number;
    export var Z_FIXED: number;
    export var Z_DEFAULT_STRATEGY: number;
    export var Z_BINARY: number;
    export var Z_TEXT: number;
    export var Z_ASCII: number;
    export var Z_UNKNOWN: number;
    export var Z_DEFLATED: number;
    export var Z_NULL: number;
}

declare module &quot;os&quot; {
    export function tmpDir(): string;
    export function hostname(): string;
    export function type(): string;
    export function platform(): string;
    export function arch(): string;
    export function release(): string;
    export function uptime(): number;
    export function loadavg(): number[];
    export function totalmem(): number;
    export function freemem(): number;
    export function cpus(): { model: string; speed: number; times: { user: number; nice: number; sys: number; idle: number; irq: number; }; }[];
    export function networkInterfaces(): any;
    export var EOL: string;
}

declare module &quot;https&quot; {
    import tls = module(&quot;tls&quot;);
    import events = module(&quot;events&quot;);
    import http = module(&quot;http&quot;);

    export interface ServerOptions {
        pfx?: any;
        key?: any;
        passphrase?: string;
        cert?: any;
        ca?: any;
        crl?: any;
        ciphers?: string;
        honorCipherOrder?: bool;
        requestCert?: bool;
        rejectUnauthorized?: bool;
        NPNProtocols?: any;
        SNICallback?: (servername: string) =&gt; any;
    }

    export interface RequestOptions {
        host?: string;
        hostname?: string;
        port?: number;
        path?: string;
        method?: string;
        headers?: any;
        auth?: string;
        agent?: any;
        pfx?: any;
        key?: any;
        passphrase?: string;
        cert?: any;
        ca?: any;
        ciphers?: string;
        rejectUnauthorized?: bool;
    }

    export interface NodeAgent {
        maxSockets: number;
        sockets: any;
        requests: any;
    }
    export var Agent: {
        new (options?: RequestOptions): NodeAgent;
    };
    export interface Server extends tls.Server { }
    export function createServer(options: ServerOptions, requestListener?: Function): Server;
    export function request(options: RequestOptions, callback?: (res: events.NodeEventEmitter) =&gt;void ): http.ClientRequest;
    export function get(options: RequestOptions, callback?: (res: events.NodeEventEmitter) =&gt;void ): http.ClientRequest;
    export var globalAgent: NodeAgent;
}

declare module &quot;punycode&quot; {
    export function decode(string: string): string;
    export function encode(string: string): string;
    export function toUnicode(domain: string): string;
    export function toASCII(domain: string): string;
    export var ucs2: ucs2;
    interface ucs2 {
        decode(string: string): string;
        encode(codePoints: number[]): string;
    }
    export var version;
}

declare module &quot;repl&quot; {
    import stream = module(&quot;stream&quot;);
    import events = module(&quot;events&quot;);

    export interface ReplOptions {
        prompt?: string;
        input?: stream.ReadableStream;
        output?: stream.WritableStream;
        terminal?: bool;
        eval?: Function;
        useColors?: bool;
        useGlobal?: bool;
        ignoreUndefined?: bool;
        writer?: Function;
    }
    export function start(options: ReplOptions): events.NodeEventEmitter;
}

declare module &quot;readline&quot; {
    import events = module(&quot;events&quot;);
    import stream = module(&quot;stream&quot;);

    export interface ReadLine extends events.NodeEventEmitter {
        setPrompt(prompt: string, length: number): void;
        prompt(preserveCursor?: bool): void;
        question(query: string, callback: Function): void;
        pause(): void;
        resume(): void;
        close(): void;
        write(data: any, key?: any): void;
    }
    export interface ReadLineOptions {
        input: stream.ReadableStream;
        output: stream.WritableStream;
        completer?: Function;
        terminal?: bool;
    }
    export function createInterface(options: ReadLineOptions): ReadLine;
}

declare module &quot;vm&quot; {
    export interface Context { }
    export interface Script {
        runInThisContext(): void;
        runInNewContext(sandbox?: Context): void;
    }
    export function runInThisContext(code: string, filename?: string): void;
    export function runInNewContext(code: string, sandbox?: Context, filename?: string): void;
    export function runInContext(code: string, context: Context, filename?: string): void;
    export function createContext(initSandbox?: Context): Context;
    export function createScript(code: string, filename?: string): Script;
}

declare module &quot;child_process&quot; {
    import events = module(&quot;events&quot;);
    import stream = module(&quot;stream&quot;);

    export interface ChildProcess extends events.NodeEventEmitter {
        stdin: stream.WritableStream;
        stdout: stream.ReadableStream;
        stderr: stream.ReadableStream;
        pid: number;
        kill(signal?: string): void;
        send(message: any, sendHandle: any): void;
        disconnect(): void;
    }

    export function spawn(command: string, args?: string[], options?: {
        cwd?: string;
        stdio?: any;
        custom?: any;
        env?: any;
        detached?: bool;
    }): ChildProcess;
    export function exec(command: string, options: {
        cwd?: string;
        stdio?: any;
        customFds?: any;
        env?: any;
        encoding?: string;
        timeout?: number;
        maxBuffer?: number;
        killSignal?: string;
    }, callback: (error: Error, stdout: NodeBuffer, stderr: NodeBuffer) =&gt;void ): ChildProcess;
    export function exec(command: string, callback: (error: Error, stdout: NodeBuffer, stderr: NodeBuffer) =&gt;void ): ChildProcess;
    export function execFile(file: string, args: string[], options: {
        cwd?: string;
        stdio?: any;
        customFds?: any;
        env?: any;
        encoding?: string;
        timeout?: number;
        maxBuffer?: string;
        killSignal?: string;
    }, callback: (error: Error, stdout: NodeBuffer, stderr: NodeBuffer) =&gt;void ): ChildProcess;
    export function fork(modulePath: string, args?: string[], options?: {
        cwd?: string;
        env?: any;
        encoding?: string;
    }): ChildProcess;
}

declare module &quot;url&quot; {
    export interface Url {
        href: string;
        protocol: string;
        auth: string;
        hostname: string;
        port: string;
        host: string;
        pathname: string;
        search: string;
        query: string;
        slashes: bool;
    }

    export function parse(urlStr: string, parseQueryString? , slashesDenoteHost? ): Url;
    export function format(url: Url): string;
    export function resolve(from: string, to: string): string;
}

declare module &quot;dns&quot; {
    export function lookup(domain: string, family: number, callback: (err: Error, address: string, family: number) =&gt;void ): string;
    export function lookup(domain: string, callback: (err: Error, address: string, family: number) =&gt;void ): string;
    export function resolve(domain: string, rrtype: string, callback: (err: Error, addresses: string[]) =&gt;void ): string[];
    export function resolve(domain: string, callback: (err: Error, addresses: string[]) =&gt;void ): string[];
    export function resolve4(domain: string, callback: (err: Error, addresses: string[]) =&gt;void ): string[];
    export function resolve6(domain: string, callback: (err: Error, addresses: string[]) =&gt;void ): string[];
    export function resolveMx(domain: string, callback: (err: Error, addresses: string[]) =&gt;void ): string[];
    export function resolveTxt(domain: string, callback: (err: Error, addresses: string[]) =&gt;void ): string[];
    export function resolveSrv(domain: string, callback: (err: Error, addresses: string[]) =&gt;void ): string[];
    export function resolveNs(domain: string, callback: (err: Error, addresses: string[]) =&gt;void ): string[];
    export function resolveCname(domain: string, callback: (err: Error, addresses: string[]) =&gt;void ): string[];
    export function reverse(ip: string, callback: (err: Error, domains: string[]) =&gt;void ): string[];
}

declare module &quot;net&quot; {
    import stream = module(&quot;stream&quot;);

    export interface NodeSocket extends stream.ReadWriteStream {
        &#x2F;&#x2F; Extended base methods
        write(str: string, encoding?: string, fd?: string): bool;
        write(buffer: NodeBuffer): bool;

        connect(port: number, host?: string, connectionListener?: Function): void;
        connect(path: string, connectionListener?: Function): void;
        bufferSize: number;
        setEncoding(encoding?: string): void;
        write(data: any, encoding?: string, callback?: Function): void;
        end(data?: any, encoding?: string): void;
        destroy(): void;
        pause(): void;
        resume(): void;
        setTimeout(timeout: number, callback?: Function); void;
        setNoDelay(noDelay?: bool): void;
        setKeepAlive(enable?: bool, initialDelay?: number): void;
        address(): { port: number; family: string; address: string; };
        remoteAddress: string;
        remotePort: number;
        bytesRead: number;
        bytesWritten: number;
    }

    export var Socket: {
        new (options?: { fd?: string; type?: string; allowHalfOpen?: bool; }): NodeSocket;
    };

    export interface Server extends NodeSocket {
        listen(port: number, host?: string, backlog?: number, listeningListener?: Function): void;
        listen(path: string, listeningListener?: Function): void;
        listen(handle: any, listeningListener?: Function): void;
        close(callback?: Function): void;
        address(): { port: number; family: string; address: string; };
        maxConnections: number;
        connections: number;
    }
    export function createServer(connectionListener?: (socket: NodeSocket) =&gt;void ): Server;
    export function createServer(options?: { allowHalfOpen?: bool; }, connectionListener?: (socket: NodeSocket) =&gt;void ): Server;
    export function connect(options: { allowHalfOpen?: bool; }, connectionListener?: Function): void;
    export function connect(port: number, host?: string, connectionListener?: Function): void;
    export function connect(path: string, connectionListener?: Function): void;
    export function createConnection(options: { allowHalfOpen?: bool; }, connectionListener?: Function): void;
    export function createConnection(port: number, host?: string, connectionListener?: Function): void;
    export function createConnection(path: string, connectionListener?: Function): void;
    export function isIP(input: string): number;
    export function isIPv4(input: string): bool;
    export function isIPv6(input: string): bool;
}

declare module &quot;dgram&quot; {
    import events = module(&quot;events&quot;);

    export function createSocket(type: string, callback?: Function): Socket;

    interface Socket extends events.NodeEventEmitter {
        send(buf: NodeBuffer, offset: number, length: number, port: number, address: string, callback?: Function): void;
        bind(port: number, address?: string): void;
        close(): void;
        address: { address: string; family: string; port: number; };
        setBroadcast(flag: bool): void;
        setMulticastTTL(ttl: number): void;
        setMulticastLoopback(flag: bool): void;
        addMembership(multicastAddress: string, multicastInterface?: string): void;
        dropMembership(multicastAddress: string, multicastInterface?: string): void;
    }
}

declare module &quot;fs&quot; {
    import stream = module(&quot;stream&quot;);

    interface Stats {
        isFile(): bool;
        isDirectory(): bool;
        isBlockDevice(): bool;
        isCharacterDevice(): bool;
        isSymbolicLink(): bool;
        isFIFO(): bool;
        isSocket(): bool;
        dev: number;
        ino: number;
        mode: number;
        nlink: number;
        uid: number;
        gid: number;
        rdev: number;
        size: number;
        blksize: number;
        blocks: number;
        atime: Date;
        mtime: Date;
        ctime: Date;
    }

    interface FSWatcher {
        close(): void;
    }

    export interface ReadStream extends stream.ReadableStream { }
    export interface WriteStream extends stream.WritableStream { }

    export function rename(oldPath: string, newPath: string, callback?: Function): void;
    export function renameSync(oldPath: string, newPath: string): void;
    export function truncate(fd: string, len: number, callback?: Function): void;
    export function truncateSync(fd: string, len: number): void;
    export function chown(path: string, uid: number, gid: number, callback?: Function): void;
    export function chownSync(path: string, uid: number, gid: number): void;
    export function fchown(fd: string, uid: number, gid: number, callback?: Function): void;
    export function fchownSync(fd: string, uid: number, gid: number): void;
    export function lchown(path: string, uid: number, gid: number, callback?: Function): void;
    export function lchownSync(path: string, uid: number, gid: number): void;
    export function chmod(path: string, mode: string, callback?: Function): void;
    export function chmodSync(path: string, mode: string): void;
    export function fchmod(fd: string, mode: string, callback?: Function): void;
    export function fchmodSync(fd: string, mode: string): void;
    export function lchmod(path: string, mode: string, callback?: Function): void;
    export function lchmodSync(path: string, mode: string): void;
    export function stat(path: string, callback?: (err: Error, stats: Stats) =&gt;any): Stats;
    export function lstat(path: string, callback?: (err: Error, stats: Stats) =&gt;any): Stats;
    export function fstat(fd: string, callback?: (err: Error, stats: Stats) =&gt;any): Stats;
    export function statSync(path: string): Stats;
    export function lstatSync(path: string): Stats;
    export function fstatSync(fd: string): Stats;
    export function link(srcpath: string, dstpath: string, callback?: Function): void;
    export function linkSync(srcpath: string, dstpath: string): void;
    export function symlink(srcpath: string, dstpath: string, type?: string, callback?: Function): void;
    export function symlinkSync(srcpath: string, dstpath: string, type?: string): void;
    export function readlink(path: string, callback?: (err: Error, linkString: string) =&gt;any): void;
    export function realpath(path: string, callback?: (err: Error, resolvedPath: string) =&gt;any): void;
    export function realpath(path: string, cache: string, callback: (err: Error, resolvedPath: string) =&gt;any): void;
    export function realpathSync(path: string, cache?: string): string;
    export function unlink(path: string, callback?: Function): void;
    export function unlinkSync(path: string): void;
    export function rmdir(path: string, callback?: Function): void;
    export function rmdirSync(path: string): void;
    export function mkdir(path: string, mode?: number, callback?: Function): void;
    export function mkdirSync(path: string, mode?: number): void;
    export function readdir(path: string, callback?: (err: Error, files: string[]) =&gt; void): void;
    export function readdirSync(path: string): string[];
    export function close(fd: string, callback?: Function): void;
    export function closeSync(fd: string): void;
    export function open(path: string, flags: string, mode?: string, callback?: (err: Error, fd: string) =&gt;any): void;
    export function openSync(path: string, flags: string, mode?: string): void;
    export function utimes(path: string, atime: number, mtime: number, callback?: Function): void;
    export function utimesSync(path: string, atime: number, mtime: number): void;
    export function futimes(fd: string, atime: number, mtime: number, callback?: Function): void;
    export function futimesSync(fd: string, atime: number, mtime: number): void;
    export function fsync(fd: string, callback?: Function): void;
    export function fsyncSync(fd: string): void;
    export function write(fd: string, buffer: NodeBuffer, offset: number, length: number, position: number, callback?: (err: Error, written: number, buffer: NodeBuffer) =&gt;any): void;
    export function writeSync(fd: string, buffer: NodeBuffer, offset: number, length: number, position: number): void;
    export function read(fd: string, buffer: NodeBuffer, offset: number, length: number, position: number, callback?: (err: Error, bytesRead: number, buffer: NodeBuffer) =&gt; void): void;
    export function readSync(fd: string, buffer: NodeBuffer, offset: number, length: number, position: number): any[];
    export function readFile(filename: string, encoding: string, callback: (err: Error, data: NodeBuffer) =&gt; void ): void;
    export function readFile(filename: string, callback: (err: Error, data: NodeBuffer) =&gt; void ): void;
    export function readFileSync(filename: string): NodeBuffer;
    export function readFileSync(filename: string, encoding: string): String;
    export function writeFile(filename: string, data: any, encoding?: string, callback?: Function): void;
    export function writeFileSync(filename: string, data: any, encoding?: string): void;
    export function appendFile(filename: string, data: any, encoding?: string, callback?: Function): void;
    export function appendFileSync(filename: string, data: any, encoding?: string): void;
    export function watchFile(filename: string, listener: { curr: Stats; prev: Stats; }): void;
    export function watchFile(filename: string, options: { persistent?: bool; interval?: number; }, listener: { curr: Stats; prev: Stats; }): void;
    export function unwatchFile(filename: string, listener?: Stats): void;
    export function watch(filename: string, options?: { persistent?: bool; }, listener?: (event: string, filename: string) =&gt;any): FSWatcher;
    export function exists(path: string, callback?: (exists: bool) =&gt;void ): void;
    export function existsSync(path: string): bool;
    export function createReadStream(path: string, options?: {
        flags?: string;
        encoding?: string;
        fd?: string;
        mode?: number;
        bufferSize?: number;
    }): ReadStream;
    export function createWriteStream(path: string, options?: {
        flags?: string;
        encoding?: string;
        string?: string;
    }): WriteStream;
}

declare module &quot;path&quot; {
    export function normalize(p: string): string;
    export function join(...paths: any[]): string;
    export function resolve(to: string): string;
    export function resolve(from: string, to: string): string;
    export function resolve(from: string, from2: string, to: string): string;
    export function resolve(from: string, from2: string, from3: string, to: string): string;
    export function resolve(from: string, from2: string, from3: string, from4: string, to: string): string;
    export function resolve(from: string, from2: string, from3: string, from4: string, from5: string, to: string): string;
    export function relative(from: string, to: string): string;
    export function dirname(p: string): string;
    export function basename(p: string, ext?: string): string;
    export function extname(p: string): string;
    export var sep: string;
}

declare module &quot;string_decoder&quot; {
    export interface NodeStringDecoder {
        write(buffer: NodeBuffer): string;
        detectIncompleteChar(buffer: NodeBuffer): number;
    }
    export var StringDecoder: {
        new (encoding: string): NodeStringDecoder;
    };
}

declare module &quot;tls&quot; {
    import crypto = module(&quot;crypto&quot;);
    import net = module(&quot;net&quot;);
    import stream = module(&quot;stream&quot;);

    var CLIENT_RENEG_LIMIT: number;
    var CLIENT_RENEG_WINDOW: number;

    export interface TlsOptions {
        pfx?: any;   &#x2F;&#x2F;string or buffer
        key?: any;   &#x2F;&#x2F;string or buffer
        passphrase?: string;
        cert?: any;
        ca?: any;    &#x2F;&#x2F;string or buffer
        crl?: any;   &#x2F;&#x2F;string or string array
        ciphers?: string;
        honorCipherOrder?: any;
        requestCert?: bool;
        rejectUnauthorized?: bool;
        NPNProtocols?: any;  &#x2F;&#x2F;array or Buffer;
        SNICallback?: (servername: string) =&gt; any;
    }

    export interface ConnectionOptions {
        host?: string;
        port?: number;
        socket?: net.NodeSocket;
        pfx?: any;   &#x2F;&#x2F;string | Buffer
        key?: any;   &#x2F;&#x2F;string | Buffer
        passphrase?: string;
        cert?: any;  &#x2F;&#x2F;string | Buffer
        ca?: any;    &#x2F;&#x2F;Array of string | Buffer
        rejectUnauthorized?: bool;
        NPNProtocols?: any;  &#x2F;&#x2F;Array of string | Buffer
        servername?: string;
    }

    export interface Server extends net.Server {
        &#x2F;&#x2F; Extended base methods
        listen(port: number, host?: string, backlog?: number, listeningListener?: Function): void;
        listen(path: string, listeningListener?: Function): void;
        listen(handle: any, listeningListener?: Function): void;

        listen(port: number, host?: string, callback?: Function): void;
        close(): void;
        address(): { port: number; family: string; address: string; };
        addContext(hostName: string, credentials: {
            key: string;
            cert: string;
            ca: string;
        }): void;
        maxConnections: number;
        connections: number;
    }

    export interface ClearTextStream extends stream.ReadWriteStream {
        authorized: bool;
        authorizationError: Error;
        getPeerCertificate(): any;
        getCipher: {
            name: string;
            version: string;
        };
        address: {
            port: number;
            family: string;
            address: string;
        };
        remoteAddress: string;
        remotePort: number;
    }

    export interface SecurePair {
        encrypted: any;
        cleartext: any;
    }

    export function createServer(options: TlsOptions, secureConnectionListener?: (cleartextStream: ClearTextStream) =&gt;void ): Server;
    export function connect(options: TlsOptions, secureConnectionListener?: () =&gt;void ): ClearTextStream;
    export function connect(port: number, host?: string, options?: ConnectionOptions, secureConnectListener?: () =&gt;void ): ClearTextStream;
    export function connect(port: number, options?: ConnectionOptions, secureConnectListener?: () =&gt;void ): ClearTextStream;
    export function createSecurePair(credentials?: crypto.Credentials, isServer?: bool, requestCert?: bool, rejectUnauthorized?: bool): SecurePair;
}

declare module &quot;crypto&quot; {
    export interface CredentialDetails {
        pfx: string;
        key: string;
        passphrase: string;
        cert: string;
        ca: any;    &#x2F;&#x2F;string | string array
        crl: any;   &#x2F;&#x2F;string | string array
        ciphers: string;
    }
    export interface Credentials { context?: any; }
    export function createCredentials(details: CredentialDetails): Credentials;
    export function createHash(algorithm: string): Hash;
    interface Hash {
        update(data: any, input_encoding?: string): void;
        digest(encoding?: string): any;
        createHmac(algorithm: string, key: string): Hmac;
    }
    interface Hmac {
        update(data: any): void;
        digest(encoding?: string): void;
    }
    export function createCipher(algorithm: string, password: any): Cipher;
    export function createCipheriv(algorithm: string, key: any, iv: any): Cipher;
    interface Cipher {
        update(data: any, input_encoding?: string, output_encoding?: string): string;
        final(output_encoding?: string): string;
        setAutoPadding(auto_padding: bool): void;
        createDecipher(algorithm: string, password: any): Decipher;
        createDecipheriv(algorithm: string, key: any, iv: any): Decipher;
    }
    interface Decipher {
        update(data: any, input_encoding?: string, output_encoding?: string): void;
        final(output_encoding?: string): string;
        setAutoPadding(auto_padding: bool): void;
    }
    export function createSign(algorithm: string): Signer;
    interface Signer {
        update(data: any): void;
        sign(private_key: string, output_format: string): string;
    }
    export function createVerify(algorith: string): Verify;
    interface Verify {
        update(data: any): void;
        verify(object: string, signature: string, signature_format?: string): bool;
    }
    export function createDiffieHellman(prime_length: number): DiffieHellman;
    export function createDiffieHellman(prime: number, encoding?: string): DiffieHellman;
    interface DiffieHellman {
        generateKeys(encoding?: string): string;
        computeSecret(other_public_key: string, input_encoding?: string, output_encoding?: string): string;
        getPrime(encoding?: string): string;
        getGenerator(encoding: string): string;
        getPublicKey(encoding?: string): string;
        getPrivateKey(encoding?: string): string;
        setPublicKey(public_key: string, encoding?: string): void;
        setPrivateKey(public_key: string, encoding?: string): void;
    }
    export function getDiffieHellman(group_name: string): DiffieHellman;
    export function pbkdf2(password: string, salt: string, iterations: number, keylen: number, callback: (err: Error, derivedKey: string) =&gt; any): void;
    export function randomBytes(size: number, callback?: (err: Error, buf: NodeBuffer) =&gt;void );
}

declare module &quot;stream&quot; {
    import events = module(&quot;events&quot;);

    export interface WritableStream extends events.NodeEventEmitter {
        writable: bool;
        write(str: string, encoding?: string, fd?: string): bool;
        write(buffer: NodeBuffer): bool;
        end(): void;
        end(str: string, enconding: string): void;
        end(buffer: NodeBuffer): void;
        destroy(): void;
        destroySoon(): void;
    }

    export interface ReadableStream extends events.NodeEventEmitter {
        readable: bool;
        setEncoding(encoding: string): void;
        pause(): void;
        resume(): void;
        destroy(): void;
        pipe(destination: WritableStream, options?: { end?: bool; }): void;
    }

    export interface ReadWriteStream extends ReadableStream, WritableStream { }
}

declare module &quot;util&quot; {
    export function format(format: any, ...param: any[]): string;
    export function debug(string: string): void;
    export function error(...param: any[]): void;
    export function puts(...param: any[]): void;
    export function print(...param: any[]): void;
    export function log(string: string): void;
    export function inspect(object: any, showHidden?: bool, depth?: number, color?: bool): void;
    export function isArray(object: any): bool;
    export function isRegExp(object: any): bool;
    export function isDate(object: any): bool;
    export function isError(object: any): bool;
    export function inherits(constructor: any, superConstructor: any): void;
}

declare module &quot;assert&quot; {
    export function fail(actual: any, expected: any, message: string, operator: string): void;
    export function assert(value: any, message: string): void;
    export function ok(value: any, message?: string): void;
    export function equal(actual: any, expected: any, message?: string): void;
    export function notEqual(actual: any, expected: any, message?: string): void;
    export function deepEqual(actual: any, expected: any, message?: string): void;
    export function notDeepEqual(acutal: any, expected: any, message?: string): void;
    export function strictEqual(actual: any, expected: any, message?: string): void;
    export function notStrictEqual(actual: any, expected: any, message?: string): void;
    export function throws(block: any, error?: any, messsage?: string): void;
    export function doesNotThrow(block: any, error?: any, messsage?: string): void;
    export function ifError(value: any): void;
}

declare module &quot;tty&quot; {
    import net = module(&quot;net&quot;);

    export function isatty(fd: string): bool;
    export interface ReadStream extends net.NodeSocket {
        isRaw: bool;
        setRawMode(mode: bool): void;
    }
    export interface WriteStream extends net.NodeSocket {
        columns: number;
        rows: number;
    }
}

declare module &quot;domain&quot; {
    import events = module(&quot;events&quot;);

    export interface Domain extends events.NodeEventEmitter { }

    export function create(): Domain;
    export function run(fn: Function): void;
    export function add(emitter: events.NodeEventEmitter): void;
    export function remove(emitter: events.NodeEventEmitter): void;
    export function bind(cb: (er: Error, data: any) =&gt;any): any;
    export function intercept(cb: (data: any) =&gt; any): any;
    export function dispose(): void;
}
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
